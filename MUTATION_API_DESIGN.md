# Mutation API Design for SharingInstant

## Executive Summary

This document explores how to provide explicit mutation methods (create, update, delete, link, unlink) through Swift's `@Shared` property wrapper, avoiding the problematic diff-based approach.

---

## The Goal

Instead of:
```swift
// ❌ Current approach - triggers diff computation, causes race conditions
$goals.withLock { $0.insert(newGoal) }
```

We want:
```swift
// ✅ Explicit operation - generates transaction chunk directly
$goals.create(title: "New Goal", difficulty: 5)
$goals.delete(id: goalId)
$goals.link(goalId, "creator", to: profileId)
```

---

## Approach 1: Extension on Shared<[Entity]>

We can extend `Shared` when the wrapped value is an array of entities:

```swift
extension Shared where Value == [Goal] {
    /// Create a new goal and send to server
    func create(title: String, difficulty: Int? = nil) async throws {
        let id = UUID().uuidString.lowercased()
        let goal = Goal(id: id, title: title, difficulty: difficulty)
        
        // 1. Apply optimistically to local state
        withLock { $0.append(goal) }
        
        // 2. Send explicit transaction to server
        let chunk = TransactionChunk(
            namespace: "goals",
            id: id,
            ops: [["update", "goals", id, ["title": title, "difficulty": difficulty]]]
        )
        try await InstantSyncKey.reactor.transact(appID: appID, chunks: [chunk])
    }
    
    /// Delete a goal by ID
    func delete(id: String) async throws {
        // 1. Apply optimistically
        withLock { $0.removeAll { $0.id == id } }
        
        // 2. Send explicit delete transaction
        let chunk = TransactionChunk(
            namespace: "goals",
            id: id,
            ops: [["delete", "goals", id]]
        )
        try await InstantSyncKey.reactor.transact(appID: appID, chunks: [chunk])
    }
}
```

### Pros
- Simple to implement
- Type-safe
- Works with existing `@Shared` infrastructure

### Cons
- Requires extension for EVERY entity type
- Hardcodes namespace strings
- Doesn't leverage the schema

---

## Approach 2: Protocol-Based with Entity Conformance

Define a protocol that entities conform to:

```swift
protocol InstantMutableEntity: InstantEntity {
    static var namespace: String { get }
    static func createChunk(id: String, attributes: [String: Any]) -> TransactionChunk
    static func deleteChunk(id: String) -> TransactionChunk
    static func linkChunk(id: String, label: String, toId: String, toNamespace: String) -> TransactionChunk
}

// Generated by @Entity macro:
extension Goal: InstantMutableEntity {
    static var namespace: String { "goals" }
    
    static func createChunk(id: String, attributes: [String: Any]) -> TransactionChunk {
        TransactionChunk(namespace: namespace, id: id, ops: [["update", namespace, id, attributes]])
    }
    
    static func deleteChunk(id: String) -> TransactionChunk {
        TransactionChunk(namespace: namespace, id: id, ops: [["delete", namespace, id]])
    }
    
    static func linkChunk(id: String, label: String, toId: String, toNamespace: String) -> TransactionChunk {
        TransactionChunk(namespace: namespace, id: id, ops: [
            ["link", namespace, id, [label: ["id": toId, "namespace": toNamespace]]]
        ])
    }
}

// Then generic extension:
extension Shared where Value: RangeReplaceableCollection, Value.Element: InstantMutableEntity {
    func create(_ element: Value.Element) async throws {
        // 1. Optimistic update
        withLock { $0.append(element) }
        
        // 2. Extract attributes and send
        let attrs = extractAttributes(from: element)
        let chunk = Value.Element.createChunk(id: element.id, attributes: attrs)
        try await reactor.transact(chunks: [chunk])
    }
    
    func delete(id: String) async throws {
        withLock { $0.removeAll { $0.id == id } }
        let chunk = Value.Element.deleteChunk(id: id)
        try await reactor.transact(chunks: [chunk])
    }
}
```

### Pros
- Generic - works for any entity
- Leverages existing `@Entity` macro
- Type-safe

### Cons
- Requires protocol conformance
- Still need to extract attributes via reflection

---

## Approach 3: Wrapper Type with Explicit API

Create a wrapper type that provides explicit mutation methods:

```swift
/// A wrapper around @Shared that provides explicit mutation methods
@propertyWrapper
struct SharedInstant<Entity: InstantEntity> {
    private var shared: Shared<[Entity]>
    private let configuration: InstantSyncConfiguration<Entity>
    
    var wrappedValue: [Entity] {
        get { shared.wrappedValue }
        set { shared.wrappedValue = newValue }
    }
    
    var projectedValue: SharedInstantProjection<Entity> {
        SharedInstantProjection(shared: shared, configuration: configuration)
    }
}

struct SharedInstantProjection<Entity: InstantEntity> {
    let shared: Shared<[Entity]>
    let configuration: InstantSyncConfiguration<Entity>
    
    /// Create a new entity
    func create(_ entity: Entity) async throws {
        // Optimistic + explicit transaction
    }
    
    /// Delete by ID
    func delete(id: String) async throws {
        // Optimistic + explicit transaction
    }
    
    /// Update specific fields
    func update(id: String, _ updates: (inout Entity) -> Void) async throws {
        // Optimistic + explicit transaction
    }
    
    /// Link to another entity
    func link(_ id: String, _ label: String, to targetId: String) async throws {
        // Explicit link transaction
    }
}
```

Usage:
```swift
@SharedInstant(.instantSync(Schema.goals)) var goals: [Goal]

// Explicit mutations:
try await $goals.create(Goal(id: UUID().uuidString, title: "New"))
try await $goals.delete(id: goalId)
try await $goals.update(id: goalId) { $0.title = "Updated" }
try await $goals.link(goalId, "creator", to: profileId)
```

### Pros
- Clean API
- Explicit operations
- Type-safe
- No diff computation

### Cons
- New property wrapper (can't use standard `@Shared`)
- Requires more infrastructure

---

## Approach 4: Result Builder DSL (Most Magical)

Use Swift's result builders to create a DSL:

```swift
@SharedInstant(.instantSync(Schema.goals)) var goals: [Goal]

// Transaction DSL:
try await $goals.transact {
    Create(Goal(id: id, title: "New Goal"))
    Update(id: existingId, title: "Updated Title")
    Delete(id: oldId)
    Link(id: goalId, "creator", to: profileId)
}
```

Implementation:
```swift
@resultBuilder
struct TransactionBuilder<Entity: InstantEntity> {
    static func buildBlock(_ components: TransactionOperation<Entity>...) -> [TransactionChunk] {
        components.flatMap { $0.chunks }
    }
}

enum TransactionOperation<Entity: InstantEntity> {
    case create(Entity)
    case update(id: String, attributes: [String: Any])
    case delete(id: String)
    case link(id: String, label: String, toId: String)
    
    var chunks: [TransactionChunk] {
        switch self {
        case .create(let entity):
            return [Entity.createChunk(from: entity)]
        case .update(let id, let attrs):
            return [Entity.updateChunk(id: id, attributes: attrs)]
        case .delete(let id):
            return [Entity.deleteChunk(id: id)]
        case .link(let id, let label, let toId):
            return [Entity.linkChunk(id: id, label: label, toId: toId)]
        }
    }
}
```

### Pros
- Very expressive
- Batch operations in single transaction
- Type-safe
- Feels native to Swift

### Cons
- Complex implementation
- Learning curve
- May be overkill for simple operations

---

## Approach 5: Macro-Generated Mutation Methods (Most Integrated)

Enhance the `@Entity` macro to generate mutation methods that integrate with `@Shared`:

```swift
@Entity("goals")
struct Goal {
    let id: String
    var title: String
    var difficulty: Int?
    
    @Link var creator: Profile?
}

// Macro generates:
extension Goal {
    /// Create a new Goal with explicit transaction
    static func create(
        in shared: Shared<[Goal]>,
        title: String,
        difficulty: Int? = nil
    ) async throws -> Goal {
        let id = UUID().uuidString.lowercased()
        let goal = Goal(id: id, title: title, difficulty: difficulty)
        
        // Optimistic update
        shared.withLock { $0.append(goal) }
        
        // Explicit transaction
        try await InstantSyncKey.transact(
            TransactionChunk(namespace: "goals", id: id, ops: [
                ["update", "goals", id, ["title": title, "difficulty": difficulty]]
            ])
        )
        
        return goal
    }
    
    /// Delete this Goal
    func delete(from shared: Shared<[Goal]>) async throws {
        shared.withLock { $0.removeAll { $0.id == self.id } }
        try await InstantSyncKey.transact(
            TransactionChunk(namespace: "goals", id: self.id, ops: [
                ["delete", "goals", self.id]
            ])
        )
    }
    
    /// Link this Goal to a Profile
    func link(creator profile: Profile, in shared: Shared<[Goal]>) async throws {
        // Update local state
        shared.withLock { goals in
            if let idx = goals.firstIndex(where: { $0.id == self.id }) {
                goals[idx].creator = profile
            }
        }
        
        // Explicit link transaction
        try await InstantSyncKey.transact(
            TransactionChunk(namespace: "goals", id: self.id, ops: [
                ["link", "goals", self.id, ["creator": ["id": profile.id, "namespace": "profiles"]]]
            ])
        )
    }
}
```

Usage:
```swift
@Shared(.instantSync(Schema.goals.with(\.creator))) var goals: [Goal]

// Create
let newGoal = try await Goal.create(in: $goals, title: "New Goal")

// Delete
try await goal.delete(from: $goals)

// Link
try await goal.link(creator: profile, in: $goals)
```

### Pros
- Fully integrated with existing `@Entity` macro
- Type-safe with compile-time checks
- Explicit operations
- Uses existing `@Shared` infrastructure

### Cons
- Requires passing `$goals` to each method
- More verbose than `$goals.create(...)`
- Macro complexity

---

## Recommended Approach: Hybrid (Approach 2 + 3)

Combine the protocol-based approach with a projection type:

### Step 1: Define the Protocol

```swift
public protocol InstantMutableEntity: InstantEntity {
    static var entityNamespace: String { get }
    func toAttributes() -> [String: Any]
}
```

### Step 2: Generate Protocol Conformance in @Entity Macro

The existing `@Entity` macro already generates namespace info. Add:

```swift
extension Goal: InstantMutableEntity {
    public static var entityNamespace: String { "goals" }
    
    public func toAttributes() -> [String: Any] {
        var attrs: [String: Any] = [:]
        attrs["title"] = title
        if let difficulty = difficulty { attrs["difficulty"] = difficulty }
        return attrs
    }
}
```

### Step 3: Create Mutation Extension on Shared

```swift
extension Shared where Value: RangeReplaceableCollection, Value.Element: InstantMutableEntity {
    
    /// Create and add a new entity
    @MainActor
    public func create(_ entity: Value.Element) async throws {
        // 1. Optimistic update
        withLock { $0.append(entity) }
        
        // 2. Generate explicit transaction chunk
        let chunk = TransactionChunk(
            namespace: Value.Element.entityNamespace,
            id: entity.id,
            ops: [["update", Value.Element.entityNamespace, entity.id, entity.toAttributes()]]
        )
        
        // 3. Send to server (bypasses save() diff computation)
        try await InstantSyncKey.directTransact(chunks: [chunk])
    }
    
    /// Delete an entity by ID
    @MainActor
    public func delete(id: String) async throws {
        // 1. Optimistic update
        withLock { $0.removeAll { $0.id == id } }
        
        // 2. Generate explicit delete chunk
        let chunk = TransactionChunk(
            namespace: Value.Element.entityNamespace,
            id: id,
            ops: [["delete", Value.Element.entityNamespace, id]]
        )
        
        // 3. Send to server
        try await InstantSyncKey.directTransact(chunks: [chunk])
    }
    
    /// Link an entity to another
    @MainActor
    public func link(
        _ id: String,
        _ label: String,
        to targetId: String,
        targetNamespace: String
    ) async throws {
        let chunk = TransactionChunk(
            namespace: Value.Element.entityNamespace,
            id: id,
            ops: [["link", Value.Element.entityNamespace, id, [label: ["id": targetId, "namespace": targetNamespace]]]]
        )
        try await InstantSyncKey.directTransact(chunks: [chunk])
    }
}
```

### Step 4: Add Direct Transaction Method

```swift
extension InstantSyncKey {
    /// Send transaction chunks directly to server, bypassing diff computation
    @MainActor
    static func directTransact(chunks: [TransactionChunk]) async throws {
        guard let reactor = Self.reactor else {
            throw InstantError.notConnected
        }
        try await reactor.transact(appID: currentAppID, chunks: chunks)
    }
}
```

### Usage

```swift
@Shared(.instantSync(Schema.goals.with(\.creator))) var goals: [Goal]

// Create - explicit operation, no diff
try await $goals.create(Goal(id: UUID().uuidString, title: "New Goal"))

// Delete - explicit operation, no diff
try await $goals.delete(id: goalId)

// Link - explicit operation
try await $goals.link(goalId, "creator", to: profileId, targetNamespace: "profiles")

// Still works for reading:
ForEach(goals) { goal in
    Text(goal.title)
}
```

---

## Implementation Checklist

1. [ ] Add `InstantMutableEntity` protocol to SharingInstant
2. [ ] Update `@Entity` macro to generate `toAttributes()` method
3. [ ] Add `entityNamespace` to generated code (may already exist)
4. [ ] Create `Shared` extension with `create`, `delete`, `link`, `unlink` methods
5. [ ] Add `directTransact` method that bypasses `save()` diff logic
6. [ ] Update documentation and examples
7. [ ] Add tests for explicit mutation API
8. [ ] Deprecate `withLock { $0.insert/remove }` pattern in docs

---

## Open Questions

1. **How to handle optimistic update failures?** If the server rejects the transaction, how do we roll back the optimistic update?

2. **Should we support batch operations?** Like `$goals.batch { create(...); delete(...) }`?

3. **How to handle link updates in local state?** When we link, we need to update the local entity's link property, but we might not have the full linked entity.

4. **Thread safety?** The `withLock` + async transaction is not atomic. What if another operation happens in between?

5. **Should explicit mutations skip save() entirely?** Or should save() be smart enough to not re-send explicit mutations?

---

## Conclusion

The recommended approach is the **Hybrid (Approach 2 + 3)**: Protocol-based with Shared extension. This provides:

- Clean, explicit API: `$goals.create(...)`, `$goals.delete(id:)`
- Type safety through protocols
- No diff computation - explicit operations generate specific chunks
- Minimal changes to existing architecture
- Works with existing `@Shared` infrastructure

The key insight is that **mutations should be explicit operations, not inferred from state diffs**. This matches how the TypeScript SDK works and avoids the race conditions inherent in diff-based approaches.
