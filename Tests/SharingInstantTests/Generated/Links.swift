/// ═══════════════════════════════════════════════════════════════════════════════
/// Links.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file defines link metadata for relationships between entities. Links in
/// InstantDB are bidirectional - when you link A to B, B is automatically linked
/// back to A.
/// Links enable:
/// • Type-safe relationship traversal with `.with(\.<linkName>)`
/// • Automatic foreign key management
/// • Cascade delete behavior (when configured)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Include linked entities in your queries using the `.with()` modifier:
///   Schema.boards.with(\.linkedTiles)
/// Chain multiple links:
///   Schema.boards.with(\.linkedTiles).with(\.otherLink)
/// The compiler ensures you only request links that actually exist!
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct BoardWithLinksView: View {
  /// Query boards and include their linked linkedTiles
  @Shared(Schema.boards.with(\.linkedTiles))
  private var items: IdentifiedArrayOf<Board> = []

  var body: some View {
    List(items) { item in
      VStack(alignment: .leading, spacing: 8) {
        Text("\(item.id)")
          .font(.headline)

        // Type-safe access to linked entity!
        // This is Optional because the link may not exist
        if let linked = item.linkedTiles {
          HStack {
            Image(systemName: "link")
            Text("Linked: \(linked.id)")
          }
          .font(.caption)
          .foregroundStyle(.secondary)
        }
      }
      .padding(.vertical, 4)
    }
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// TYPE SAFETY EXAMPLES
///
/// The link system is fully type-safe. The compiler catches errors at build time:
///
/// ✅ COMPILES - linkedTiles exists on Board:
///    Schema.boards.with(\.linkedTiles)
///
/// ❌ COMPILE ERROR - "nonexistent" is not a link on Board:
///    Schema.boards.with(\.nonexistent)
///    // Error: Type 'Board' has no member 'nonexistent'
///
///

/// $usersLinkedPrimaryUser {
///   name: "$usersLinkedPrimaryUser"
///
///   forward: {
///     on: InstantUser
///     label: "linkedPrimaryUser"
///     has: one
///   }
///   // Access: InstantUser.linkedPrimaryUser → InstantUser?
///
///   reverse: {
///     on: InstantUser
///     label: "linkedGuestUsers"
///     has: many
///   }
///   // Access: InstantUser.linkedGuestUsers → [InstantUser]?
/// }
///
/// boardsLinkedTiles {
///   name: "boardsLinkedTiles"
///
///   forward: {
///     on: Board
///     label: "linkedTiles"
///     has: many
///   }
///   // Access: Board.linkedTiles → [Tile]?
///
///   reverse: {
///     on: Tile
///     label: "linkedBoard"
///     has: many
///   }
///   // Access: Tile.linkedBoard → [Board]?
/// }
///
/// boardsTiles {
///   name: "boardsTiles"
///
///   forward: {
///     on: Board
///     label: "tiles"
///     has: many
///   }
///   // Access: Board.tiles → [Tile]?
///
///   reverse: {
///     on: Tile
///     label: "board"
///     has: one
///   }
///   // Access: Tile.board → Board?
/// }
///
/// postsComments {
///   name: "postsComments"
///
///   forward: {
///     on: Post
///     label: "comments"
///     has: many
///   }
///   // Access: Post.comments → [Comment]?
///
///   reverse: {
///     on: Comment
///     label: "post"
///     has: one
///   }
///   // Access: Comment.post → Post?
/// }
///
/// postsLikes {
///   name: "postsLikes"
///
///   forward: {
///     on: Post
///     label: "likes"
///     has: many
///   }
///   // Access: Post.likes → [Like]?
///
///   reverse: {
///     on: Like
///     label: "post"
///     has: one
///   }
///   // Access: Like.post → Post?
/// }
///
/// profilesComments {
///   name: "profilesComments"
///
///   forward: {
///     on: Profile
///     label: "comments"
///     has: many
///   }
///   // Access: Profile.comments → [Comment]?
///
///   reverse: {
///     on: Comment
///     label: "author"
///     has: one
///   }
///   // Access: Comment.author → Profile?
/// }
///
/// profilesLikes {
///   name: "profilesLikes"
///
///   forward: {
///     on: Profile
///     label: "likes"
///     has: many
///   }
///   // Access: Profile.likes → [Like]?
///
///   reverse: {
///     on: Like
///     label: "profile"
///     has: one
///   }
///   // Access: Like.profile → Profile?
/// }
///
/// profilesPosts {
///   name: "profilesPosts"
///
///   forward: {
///     on: Profile
///     label: "posts"
///     has: many
///   }
///   // Access: Profile.posts → [Post]?
///
///   reverse: {
///     on: Post
///     label: "author"
///     has: one
///   }
///   // Access: Post.author → Profile?
/// }
///
/// mediaTranscriptionRuns {
///   name: "mediaTranscriptionRuns"
///
///   forward: {
///     on: Media
///     label: "transcriptionRuns"
///     has: many
///   }
///   // Access: Media.transcriptionRuns → [TranscriptionRun]?
///
///   reverse: {
///     on: TranscriptionRun
///     label: "media"
///     has: one
///   }
///   // Access: TranscriptionRun.media → Media?
/// }
///
/// transcriptionRunsSegments {
///   name: "transcriptionRunsSegments"
///
///   forward: {
///     on: TranscriptionRun
///     label: "transcriptionSegments"
///     has: many
///   }
///   // Access: TranscriptionRun.transcriptionSegments → [TranscriptionSegment]?
///
///   reverse: {
///     on: TranscriptionSegment
///     label: "transcriptionRun"
///     has: one
///   }
///   // Access: TranscriptionSegment.transcriptionRun → TranscriptionRun?
/// }
///
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// GENERATION INFO
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Mode:            Production (full traceability)
/// Generated:       January 7, 2026 at 10:21 AM EST
/// Machine:         mlustig-hy7l9xrd61.local (Apple M4 Pro, macOS 26.2)
/// Generator:       Sources/instant-schema/main.swift
/// Source Schema:   instant.schema.ts

/* To regenerate this file, run:

swift run instant-schema generate \
  --from instant.schema.ts \
  --to Tests/SharingInstantTests/Generated
*/
/// ─────────────────────────────────────────────────────────────────────────────────
/// GIT STATE AT GENERATION
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// HEAD Commit:
///   SHA:      7984aa49f6505dc5906a550adc3f0c4d362a2d1d
///   Date:     January 6, 2026 at 9:55 PM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  feat: Add transcription entities to test schema
///
/// Schema File Last Modified:
///   SHA:      7984aa49f6505dc5906a550adc3f0c4d362a2d1d
///   Date:     January 6, 2026 at 9:55 PM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  feat: Add transcription entities to test schema
///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import SharingInstant

// MARK: - Link Definitions

public enum SchemaLinks {
  /// $users ↔ $users relationship
  /// - Note: Involves InstantDB system entity.
  public static let instantUsersLinkedPrimaryUser = Link(
    name: "$usersLinkedPrimaryUser",
    from: InstantUser.self, fromLabel: "linkedPrimaryUser", fromCardinality: .one,
    to: InstantUser.self, toLabel: "linkedGuestUsers", toCardinality: .many
  )

  /// boards ↔ tiles relationship
  public static let boardsLinkedTiles = Link(
    name: "boardsLinkedTiles",
    from: Board.self, fromLabel: "linkedTiles", fromCardinality: .many,
    to: Tile.self, toLabel: "linkedBoard", toCardinality: .many
  )

  /// boards ↔ tiles relationship
  public static let boardsTiles = Link(
    name: "boardsTiles",
    from: Board.self, fromLabel: "tiles", fromCardinality: .many,
    to: Tile.self, toLabel: "board", toCardinality: .one
  )

  /// posts ↔ comments relationship
  public static let postsComments = Link(
    name: "postsComments",
    from: Post.self, fromLabel: "comments", fromCardinality: .many,
    to: Comment.self, toLabel: "post", toCardinality: .one
  )

  /// posts ↔ likes relationship
  public static let postsLikes = Link(
    name: "postsLikes",
    from: Post.self, fromLabel: "likes", fromCardinality: .many,
    to: Like.self, toLabel: "post", toCardinality: .one
  )

  /// profiles ↔ comments relationship
  public static let profilesComments = Link(
    name: "profilesComments",
    from: Profile.self, fromLabel: "comments", fromCardinality: .many,
    to: Comment.self, toLabel: "author", toCardinality: .one
  )

  /// profiles ↔ likes relationship
  public static let profilesLikes = Link(
    name: "profilesLikes",
    from: Profile.self, fromLabel: "likes", fromCardinality: .many,
    to: Like.self, toLabel: "profile", toCardinality: .one
  )

  /// profiles ↔ posts relationship
  public static let profilesPosts = Link(
    name: "profilesPosts",
    from: Profile.self, fromLabel: "posts", fromCardinality: .many,
    to: Post.self, toLabel: "author", toCardinality: .one
  )

  /// media ↔ transcriptionRuns relationship
  public static let mediaTranscriptionRuns = Link(
    name: "mediaTranscriptionRuns",
    from: Media.self, fromLabel: "transcriptionRuns", fromCardinality: .many,
    to: TranscriptionRun.self, toLabel: "media", toCardinality: .one
  )

  /// transcriptionRuns ↔ transcriptionSegments relationship
  public static let transcriptionRunsSegments = Link(
    name: "transcriptionRunsSegments",
    from: TranscriptionRun.self, fromLabel: "transcriptionSegments", fromCardinality: .many,
    to: TranscriptionSegment.self, toLabel: "transcriptionRun", toCardinality: .one
  )

}

// MARK: - Link Type

/// Represents a bidirectional link between two entities.
public struct Link<From: InstantEntity, To: InstantEntity>: Sendable {
  public let name: String
  public let fromLabel: String
  public let fromCardinality: LinkCardinality
  public let toLabel: String
  public let toCardinality: LinkCardinality
  
  public init(
    name: String,
    from: From.Type,
    fromLabel: String,
    fromCardinality: LinkCardinality,
    to: To.Type,
    toLabel: String,
    toCardinality: LinkCardinality
  ) {
    self.name = name
    self.fromLabel = fromLabel
    self.fromCardinality = fromCardinality
    self.toLabel = toLabel
    self.toCardinality = toCardinality
  }
}

/// The cardinality of one side of a link.
public enum LinkCardinality: String, Sendable {
  case one
  case many
}
