/// ═══════════════════════════════════════════════════════════════════════════════
/// Schema.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file defines the `Schema` namespace containing type-safe `EntityKey`
/// instances for each entity in your InstantDB schema. EntityKeys enable:
/// • Compile-time type safety - no string literals for namespace names
/// • Autocomplete support - `Schema.` shows all available entities
/// • Chainable query modifiers - `.orderBy()`, `.where()`, `.limit()`
/// • Bidirectional sync with `@Shared` or read-only queries with `@SharedReader`
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use `Schema.<entityName>` with `@Shared` for bidirectional sync:
///   @Shared(Schema.boards)
///   private var items: IdentifiedArrayOf<Board> = []
/// Chain modifiers for ordering, filtering, and limiting:
///   Schema.boards.orderBy(\.createdAt, .desc)
///   Schema.boards.where(\.createdAt, .eq("value"))
///   Schema.boards.limit(10)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct BoardContentView: View {
  /// Bidirectional sync with InstantDB - changes sync automatically!
  @Shared(Schema.boards.orderBy(\.createdAt, .desc))
  private var items: IdentifiedArrayOf<Board> = []

  @State private var newValue = ""

  var body: some View {
    NavigationStack {
      List {
        Section("Add New") {
          HStack {
            TextField("Enter value", text: $newValue)
            Button("Add") { addItem() }
              .disabled(newValue.isEmpty)
          }
        }

        Section("Items (\(items.count))") {
          ForEach(items) { item in
            Text("\(item.id)")
          }
          .onDelete { indexSet in
            $items.withLock { items in
              for index in indexSet {
                items.remove(at: index)
              }
            }
          }
        }
      }
      .navigationTitle("Boards")
    }
  }

  private func addItem() {
    // Create and add - syncs automatically!
    let item = Board(/* ... */)
    $items.withLock { $0.append(item) }
    newValue = ""
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Schema.instantFiles → InstantFile {
///   id: String
///   path: String
///   url: String
///   // Note: InstantDB system entity
/// }
///
/// Schema.instantUsers → InstantUser {
///   id: String
///   email: String?
///   imageURL: String?
///   type: String?
///   // Note: InstantDB system entity
/// }
///
/// Schema.boards → Board {
///   id: String
///   createdAt: Double
///   title: String
/// }
///
/// Schema.comments → Comment {
///   id: String
///   createdAt: Double
///   text: String
/// }
///
/// Schema.facts → Fact {
///   id: String
///   count: Double
///   text: String
/// }
///
/// Schema.likes → Like {
///   id: String
///   createdAt: Double
/// }
///
/// Schema.logs → Log {
///   id: String
///   file: String
///   formattedDate: String
///   jsonPayload: String?
///   level: String
///   line: Double
///   message: String
///   timestamp: Double
///   timezone: String
/// }
///
/// Schema.posts → Post {
///   id: String
///   content: String
///   createdAt: Double
///   imageUrl: String?
/// }
///
/// Schema.profiles → Profile {
///   id: String
///   avatarUrl: String?
///   bio: String?
///   createdAt: Double
///   displayName: String
///   handle: String
/// }
///
/// Schema.tiles → Tile {
///   id: String
///   color: String
///   createdAt: Double
///   x: Double
///   y: Double
/// }
///
/// Schema.todos → Todo {
///   id: String
///   createdAt: Double
///   done: Bool
///   title: String
/// }
///
/// Schema.media → Media {
///   id: String
///   title: String
///   durationSeconds: Double
///   mediaType: String
///   ingestedAt: String
///   description: String?
/// }
///
/// Schema.transcriptionRuns → TranscriptionRun {
///   id: String
///   toolVersion: String
///   executedAt: String
///   runType: String?
///   isActive: Bool?
/// }
///
/// Schema.transcriptionSegments → TranscriptionSegment {
///   id: String
///   startTime: Double
///   endTime: Double
///   text: String
///   segmentIndex: Double
///   isFinalized: Bool
///   ingestedAt: String
///   speaker: Double?
///   words: AnyCodable?
/// }
///

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// GENERATION INFO
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Mode:            Production (full traceability)
/// Generated:       January 7, 2026 at 10:21 AM EST
/// Machine:         mlustig-hy7l9xrd61.local (Apple M4 Pro, macOS 26.2)
/// Generator:       Sources/instant-schema/main.swift
/// Source Schema:   instant.schema.ts

/* To regenerate this file, run:

swift run instant-schema generate \
  --from instant.schema.ts \
  --to Tests/SharingInstantTests/Generated
*/
/// ─────────────────────────────────────────────────────────────────────────────────
/// GIT STATE AT GENERATION
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// HEAD Commit:
///   SHA:      7984aa49f6505dc5906a550adc3f0c4d362a2d1d
///   Date:     January 6, 2026 at 9:55 PM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  feat: Add transcription entities to test schema
///
/// Schema File Last Modified:
///   SHA:      7984aa49f6505dc5906a550adc3f0c4d362a2d1d
///   Date:     January 6, 2026 at 9:55 PM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  feat: Add transcription entities to test schema
///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import InstantDB
import IdentifiedCollections
import SharingInstant

// MARK: - Schema Namespace

public enum Schema {
  /// InstantFile entity - bidirectional sync
  /// - Note: This is an InstantDB system entity.
  public static let instantFiles = EntityKey<InstantFile>(namespace: "$files")

  /// InstantUser entity - bidirectional sync
  /// - Note: This is an InstantDB system entity.
  public static let instantUsers = EntityKey<InstantUser>(namespace: "$users")

  /// Board entity - bidirectional sync
  public static let boards = EntityKey<Board>(namespace: "boards")

  /// Comment entity - bidirectional sync
  public static let comments = EntityKey<Comment>(namespace: "comments")

  /// Fact entity - bidirectional sync
  public static let facts = EntityKey<Fact>(namespace: "facts")

  /// Like entity - bidirectional sync
  public static let likes = EntityKey<Like>(namespace: "likes")

  /// Log entity - bidirectional sync
  public static let logs = EntityKey<Log>(namespace: "logs")

  /// Post entity - bidirectional sync
  public static let posts = EntityKey<Post>(namespace: "posts")

  /// Profile entity - bidirectional sync
  public static let profiles = EntityKey<Profile>(namespace: "profiles")

  /// Tile entity - bidirectional sync
  public static let tiles = EntityKey<Tile>(namespace: "tiles")

  /// Todo entity - bidirectional sync
  public static let todos = EntityKey<Todo>(namespace: "todos")

  /// Media entity - bidirectional sync
  public static let media = EntityKey<Media>(namespace: "media")

  /// TranscriptionRun entity - bidirectional sync
  public static let transcriptionRuns = EntityKey<TranscriptionRun>(namespace: "transcriptionRuns")

  /// TranscriptionSegment entity - bidirectional sync
  public static let transcriptionSegments = EntityKey<TranscriptionSegment>(namespace: "transcriptionSegments")

}

// MARK: - Link-Based Where Clause Extensions

public extension EntityKey where Entity == InstantUser {

  /// Filter instantusers by their linked InstantUser's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.instantUsers.whereLinkedPrimaryUser(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked InstantUser to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedPrimaryUser(id: String) -> EntityKey<InstantUser> {
    self.where("linkedPrimaryUser.id", .eq(id))
  }

  /// Filter instantusers by their linked InstantUser using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.instantUsers.whereLinkedPrimaryUser(.eq(someId))
  /// Schema.instantUsers.whereLinkedPrimaryUser(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked InstantUser's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedPrimaryUser(_ predicate: EntityKeyPredicate) -> EntityKey<InstantUser> {
    self.where("linkedPrimaryUser.id", predicate)
  }

  /// Filter instantusers by their linked InstantUser's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.instantUsers.whereLinkedGuestUsers(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked InstantUser to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedGuestUsers(id: String) -> EntityKey<InstantUser> {
    self.where("linkedGuestUsers.id", .eq(id))
  }

  /// Filter instantusers by their linked InstantUser using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.instantUsers.whereLinkedGuestUsers(.eq(someId))
  /// Schema.instantUsers.whereLinkedGuestUsers(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked InstantUser's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedGuestUsers(_ predicate: EntityKeyPredicate) -> EntityKey<InstantUser> {
    self.where("linkedGuestUsers.id", predicate)
  }
}

public extension EntityKey where Entity == Board {

  /// Filter boards by their linked Tile's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.boards.whereLinkedTiles(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Tile to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedTiles(id: String) -> EntityKey<Board> {
    self.where("linkedTiles.id", .eq(id))
  }

  /// Filter boards by their linked Tile using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.boards.whereLinkedTiles(.eq(someId))
  /// Schema.boards.whereLinkedTiles(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Tile's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedTiles(_ predicate: EntityKeyPredicate) -> EntityKey<Board> {
    self.where("linkedTiles.id", predicate)
  }

  /// Filter boards by their linked Tile's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.boards.whereTiles(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Tile to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereTiles(id: String) -> EntityKey<Board> {
    self.where("tiles.id", .eq(id))
  }

  /// Filter boards by their linked Tile using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.boards.whereTiles(.eq(someId))
  /// Schema.boards.whereTiles(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Tile's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereTiles(_ predicate: EntityKeyPredicate) -> EntityKey<Board> {
    self.where("tiles.id", predicate)
  }
}

public extension EntityKey where Entity == Comment {

  /// Filter comments by their linked Post's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.comments.wherePost(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Post to filter by
  /// - Returns: A new EntityKey with the filter applied
  func wherePost(id: String) -> EntityKey<Comment> {
    self.where("post.id", .eq(id))
  }

  /// Filter comments by their linked Post using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.comments.wherePost(.eq(someId))
  /// Schema.comments.wherePost(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Post's ID
  /// - Returns: A new EntityKey with the filter applied
  func wherePost(_ predicate: EntityKeyPredicate) -> EntityKey<Comment> {
    self.where("post.id", predicate)
  }

  /// Filter comments by their linked Profile's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.comments.whereAuthor(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Profile to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereAuthor(id: String) -> EntityKey<Comment> {
    self.where("author.id", .eq(id))
  }

  /// Filter comments by their linked Profile using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.comments.whereAuthor(.eq(someId))
  /// Schema.comments.whereAuthor(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Profile's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereAuthor(_ predicate: EntityKeyPredicate) -> EntityKey<Comment> {
    self.where("author.id", predicate)
  }
}

public extension EntityKey where Entity == Like {

  /// Filter likes by their linked Post's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.likes.wherePost(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Post to filter by
  /// - Returns: A new EntityKey with the filter applied
  func wherePost(id: String) -> EntityKey<Like> {
    self.where("post.id", .eq(id))
  }

  /// Filter likes by their linked Post using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.likes.wherePost(.eq(someId))
  /// Schema.likes.wherePost(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Post's ID
  /// - Returns: A new EntityKey with the filter applied
  func wherePost(_ predicate: EntityKeyPredicate) -> EntityKey<Like> {
    self.where("post.id", predicate)
  }

  /// Filter likes by their linked Profile's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.likes.whereProfile(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Profile to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereProfile(id: String) -> EntityKey<Like> {
    self.where("profile.id", .eq(id))
  }

  /// Filter likes by their linked Profile using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.likes.whereProfile(.eq(someId))
  /// Schema.likes.whereProfile(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Profile's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereProfile(_ predicate: EntityKeyPredicate) -> EntityKey<Like> {
    self.where("profile.id", predicate)
  }
}

public extension EntityKey where Entity == Post {

  /// Filter posts by their linked Comment's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.posts.whereComments(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Comment to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereComments(id: String) -> EntityKey<Post> {
    self.where("comments.id", .eq(id))
  }

  /// Filter posts by their linked Comment using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.posts.whereComments(.eq(someId))
  /// Schema.posts.whereComments(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Comment's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereComments(_ predicate: EntityKeyPredicate) -> EntityKey<Post> {
    self.where("comments.id", predicate)
  }

  /// Filter posts by their linked Like's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.posts.whereLikes(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Like to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereLikes(id: String) -> EntityKey<Post> {
    self.where("likes.id", .eq(id))
  }

  /// Filter posts by their linked Like using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.posts.whereLikes(.eq(someId))
  /// Schema.posts.whereLikes(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Like's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereLikes(_ predicate: EntityKeyPredicate) -> EntityKey<Post> {
    self.where("likes.id", predicate)
  }

  /// Filter posts by their linked Profile's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.posts.whereAuthor(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Profile to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereAuthor(id: String) -> EntityKey<Post> {
    self.where("author.id", .eq(id))
  }

  /// Filter posts by their linked Profile using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.posts.whereAuthor(.eq(someId))
  /// Schema.posts.whereAuthor(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Profile's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereAuthor(_ predicate: EntityKeyPredicate) -> EntityKey<Post> {
    self.where("author.id", predicate)
  }
}

public extension EntityKey where Entity == Profile {

  /// Filter profiles by their linked Comment's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.profiles.whereComments(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Comment to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereComments(id: String) -> EntityKey<Profile> {
    self.where("comments.id", .eq(id))
  }

  /// Filter profiles by their linked Comment using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.profiles.whereComments(.eq(someId))
  /// Schema.profiles.whereComments(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Comment's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereComments(_ predicate: EntityKeyPredicate) -> EntityKey<Profile> {
    self.where("comments.id", predicate)
  }

  /// Filter profiles by their linked Like's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.profiles.whereLikes(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Like to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereLikes(id: String) -> EntityKey<Profile> {
    self.where("likes.id", .eq(id))
  }

  /// Filter profiles by their linked Like using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.profiles.whereLikes(.eq(someId))
  /// Schema.profiles.whereLikes(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Like's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereLikes(_ predicate: EntityKeyPredicate) -> EntityKey<Profile> {
    self.where("likes.id", predicate)
  }

  /// Filter profiles by their linked Post's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.profiles.wherePosts(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Post to filter by
  /// - Returns: A new EntityKey with the filter applied
  func wherePosts(id: String) -> EntityKey<Profile> {
    self.where("posts.id", .eq(id))
  }

  /// Filter profiles by their linked Post using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.profiles.wherePosts(.eq(someId))
  /// Schema.profiles.wherePosts(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Post's ID
  /// - Returns: A new EntityKey with the filter applied
  func wherePosts(_ predicate: EntityKeyPredicate) -> EntityKey<Profile> {
    self.where("posts.id", predicate)
  }
}

public extension EntityKey where Entity == Tile {

  /// Filter tiles by their linked Board's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.tiles.whereLinkedBoard(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Board to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedBoard(id: String) -> EntityKey<Tile> {
    self.where("linkedBoard.id", .eq(id))
  }

  /// Filter tiles by their linked Board using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.tiles.whereLinkedBoard(.eq(someId))
  /// Schema.tiles.whereLinkedBoard(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Board's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereLinkedBoard(_ predicate: EntityKeyPredicate) -> EntityKey<Tile> {
    self.where("linkedBoard.id", predicate)
  }

  /// Filter tiles by their linked Board's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.tiles.whereBoard(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Board to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBoard(id: String) -> EntityKey<Tile> {
    self.where("board.id", .eq(id))
  }

  /// Filter tiles by their linked Board using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.tiles.whereBoard(.eq(someId))
  /// Schema.tiles.whereBoard(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Board's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBoard(_ predicate: EntityKeyPredicate) -> EntityKey<Tile> {
    self.where("board.id", predicate)
  }
}

public extension EntityKey where Entity == Media {

  /// Filter medias by their linked TranscriptionRun's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.media.whereTranscriptionRuns(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked TranscriptionRun to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscriptionRuns(id: String) -> EntityKey<Media> {
    self.where("transcriptionRuns.id", .eq(id))
  }

  /// Filter medias by their linked TranscriptionRun using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.media.whereTranscriptionRuns(.eq(someId))
  /// Schema.media.whereTranscriptionRuns(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked TranscriptionRun's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscriptionRuns(_ predicate: EntityKeyPredicate) -> EntityKey<Media> {
    self.where("transcriptionRuns.id", predicate)
  }
}

public extension EntityKey where Entity == TranscriptionRun {

  /// Filter transcriptionruns by their linked Media's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.transcriptionRuns.whereMedia(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Media to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereMedia(id: String) -> EntityKey<TranscriptionRun> {
    self.where("media.id", .eq(id))
  }

  /// Filter transcriptionruns by their linked Media using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.transcriptionRuns.whereMedia(.eq(someId))
  /// Schema.transcriptionRuns.whereMedia(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Media's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereMedia(_ predicate: EntityKeyPredicate) -> EntityKey<TranscriptionRun> {
    self.where("media.id", predicate)
  }

  /// Filter transcriptionruns by their linked TranscriptionSegment's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.transcriptionRuns.whereTranscriptionSegments(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked TranscriptionSegment to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscriptionSegments(id: String) -> EntityKey<TranscriptionRun> {
    self.where("transcriptionSegments.id", .eq(id))
  }

  /// Filter transcriptionruns by their linked TranscriptionSegment using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.transcriptionRuns.whereTranscriptionSegments(.eq(someId))
  /// Schema.transcriptionRuns.whereTranscriptionSegments(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked TranscriptionSegment's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscriptionSegments(_ predicate: EntityKeyPredicate) -> EntityKey<TranscriptionRun> {
    self.where("transcriptionSegments.id", predicate)
  }
}

public extension EntityKey where Entity == TranscriptionSegment {

  /// Filter transcriptionsegments by their linked TranscriptionRun's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.transcriptionSegments.whereTranscriptionRun(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked TranscriptionRun to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscriptionRun(id: String) -> EntityKey<TranscriptionSegment> {
    self.where("transcriptionRun.id", .eq(id))
  }

  /// Filter transcriptionsegments by their linked TranscriptionRun using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.transcriptionSegments.whereTranscriptionRun(.eq(someId))
  /// Schema.transcriptionSegments.whereTranscriptionRun(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked TranscriptionRun's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscriptionRun(_ predicate: EntityKeyPredicate) -> EntityKey<TranscriptionSegment> {
    self.where("transcriptionRun.id", predicate)
  }
}

