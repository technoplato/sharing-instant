/// ═══════════════════════════════════════════════════════════════════════════════
/// Mutations.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains type-safe mutation extensions for each entity in your
/// InstantDB schema. These methods provide explicit operations (create, update,
/// delete, link, unlink) with TanStack Query-style callbacks.
/// Benefits over withLock mutations:
/// • Explicit operations - no diff computation
/// • Type-safe field updates - compiler catches typos
/// • Semantic methods - toggleDone(), incrementLikes()
/// • Callbacks for success/error handling
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use the generated mutation methods on your @Shared collections:
///   @Shared(Schema.facts)
///   private var items: IdentifiedArrayOf<Fact> = []
///   // Create with all fields
///   $items.createFact(count: value)
///   // Update specific field
///   $items.updateCount(itemId, to: newValue)
///   // Delete by ID or entity
///   $items.deleteFact(itemId)
///   $items.deleteFact(item)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct FactMutationsView: View {
  @Shared(Schema.facts)
  private var items: IdentifiedArrayOf<Fact> = []

  var body: some View {
    List(items) { item in
      Text("\(item.id)")
    }
  }

  private func createItem() {
    $items.createFact(
      count: "value",
      callbacks: MutationCallbacks(
        onSuccess: { item in print("Created: \(item.id)") },
        onError: { error in print("Error: \(error)") }
      )
    )
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// InstantFile Mutations {
///   createInstantFile(...)
///   updatePath(_:to:)
///   updateUrl(_:to:)
///   deleteInstantFile(_:) // by ID
///   deleteInstantFile(_:) // by entity
/// }
///
/// InstantUser Mutations {
///   createInstantUser(...)
///   updateEmail(_:to:)
///   updateImageURL(_:to:)
///   updateType(_:to:)
///   deleteInstantUser(_:) // by ID
///   deleteInstantUser(_:) // by entity
/// }
///
/// Fact Mutations {
///   createFact(...)
///   updateCount(_:to:)
///   incrementCount(_:by:)
///   decrementCount(_:by:)
///   updateText(_:to:)
///   deleteFact(_:) // by ID
///   deleteFact(_:) // by entity
/// }
///
/// Log Mutations {
///   createLog(...)
///   updateLevel(_:to:)
///   updateMessage(_:to:)
///   updateJsonPayload(_:to:)
///   updateFile(_:to:)
///   updateLine(_:to:)
///   updateTimestamp(_:to:)
///   updateFormattedDate(_:to:)
///   updateTimezone(_:to:)
///   deleteLog(_:) // by ID
///   deleteLog(_:) // by entity
/// }
///
/// Todo Mutations {
///   createTodo(...)
///   updateCreatedAt(_:to:)
///   updateDone(_:to:)
///   toggleDone(_:)
///   markDone(_:)
///   unmarkDone(_:)
///   updateTitle(_:to:)
///   deleteTodo(_:) // by ID
///   deleteTodo(_:) // by entity
/// }
///
/// Profile Mutations {
///   createProfile(...)
///   updateDisplayName(_:to:)
///   updateHandle(_:to:)
///   updateBio(_:to:)
///   updateAvatarUrl(_:to:)
///   updateCreatedAt(_:to:)
///   deleteProfile(_:) // by ID
///   deleteProfile(_:) // by entity
///   linkPosts(_:to:)
///   unlinkPosts(_:from:)
///   linkComments(_:to:)
///   unlinkComments(_:from:)
///   linkLikes(_:to:)
///   unlinkLikes(_:from:)
/// }
///
/// Post Mutations {
///   createPost(...)
///   updateContent(_:to:)
///   updateImageUrl(_:to:)
///   updateCreatedAt(_:to:)
///   updateLikesCount(_:to:)
///   incrementLikesCount(_:by:)
///   decrementLikesCount(_:by:)
///   deletePost(_:) // by ID
///   deletePost(_:) // by entity
///   linkComments(_:to:)
///   unlinkComments(_:from:)
///   linkLikes(_:to:)
///   unlinkLikes(_:from:)
///   linkAuthor(_:to:)
///   unlinkAuthor(_:from:)
/// }
///
/// Comment Mutations {
///   createComment(...)
///   updateText(_:to:)
///   updateCreatedAt(_:to:)
///   deleteComment(_:) // by ID
///   deleteComment(_:) // by entity
///   linkAuthor(_:to:)
///   unlinkAuthor(_:from:)
///   linkPost(_:to:)
///   unlinkPost(_:from:)
/// }
///
/// Like Mutations {
///   createLike(...)
///   updateCreatedAt(_:to:)
///   deleteLike(_:) // by ID
///   deleteLike(_:) // by entity
///   linkProfile(_:to:)
///   unlinkProfile(_:from:)
///   linkPost(_:to:)
///   unlinkPost(_:from:)
/// }
///
/// Tile Mutations {
///   createTile(...)
///   updateX(_:to:)
///   updateY(_:to:)
///   updateColor(_:to:)
///   updateCreatedAt(_:to:)
///   deleteTile(_:) // by ID
///   deleteTile(_:) // by entity
///   linkBoard(_:to:)
///   unlinkBoard(_:from:)
/// }
///
/// Board Mutations {
///   createBoard(...)
///   updateTitle(_:to:)
///   updateCreatedAt(_:to:)
///   deleteBoard(_:) // by ID
///   deleteBoard(_:) // by entity
///   linkTiles(_:to:)
///   unlinkTiles(_:from:)
/// }
///

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// GENERATION INFO
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Mode:            Production (full traceability)
/// Generated:       December 30, 2025 at 9:29 PM EST
/// Machine:         mlustig-hy7l9xrd61.local (Apple M4 Pro, macOS 26.2)
/// Generator:       Sources/instant-schema/main.swift
/// Source Schema:   Examples/CaseStudies/instant.schema.ts

/* To regenerate this file, run:

swift run instant-schema generate \
  --from Examples/CaseStudies/instant.schema.ts \
  --to Tests/SharingInstantTests/Generated
*/
/// ─────────────────────────────────────────────────────────────────────────────────
/// GIT STATE AT GENERATION
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// HEAD Commit:
///   SHA:      409fdf941059f57f1f9c7ebdac98ed4999bc3af3
///   Date:     December 30, 2025 at 9:29 PM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  chore: Regenerate CaseStudies schema with fixed public modifiers
///
/// Schema File Last Modified:
///   SHA:      522ffbf617207b60ecfa647b2d1dc6b9bfa3a7ff
///   Date:     December 22, 2025 at 6:46 AM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  fix: Remove recursive self-link to fix Swift compilation
///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import IdentifiedCollections
import Sharing
import SharingInstant

// MARK: - InstantFile Mutations

public extension Shared where Value == IdentifiedArrayOf<InstantFile> {

  // MARK: Create

  /// Create a new InstantFile and sync to InstantDB.
  @MainActor
  public func createInstantFile(
    id: String = UUID().uuidString.lowercased(),
    path: String,
    url: String,
    callbacks: MutationCallbacks<InstantFile> = .init()
  ) {
    callbacks.onMutate?()
    let entity = InstantFile(
      id: id,
      path: path,
      url: url
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the path field of a InstantFile.
  @MainActor
  public func updatePath(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<InstantFile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.path = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the url field of a InstantFile.
  @MainActor
  public func updateUrl(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<InstantFile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.url = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a InstantFile by ID.
  @MainActor
  public func deleteInstantFile(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a InstantFile entity.
  @MainActor
  public func deleteInstantFile(
    _ entity: InstantFile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteInstantFile(entity.id, callbacks: callbacks)
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == InstantFile {

  // MARK: Create

  /// Create a new InstantFile and sync to InstantDB.
  @MainActor
  public func createInstantFile(
    id: String = UUID().uuidString.lowercased(),
    path: String,
    url: String,
    callbacks: MutationCallbacks<InstantFile> = .init()
  ) {
    callbacks.onMutate?()
    let entity = InstantFile(
      id: id,
      path: path,
      url: url
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a InstantFile by ID.
  @MainActor
  public func deleteInstantFile(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a InstantFile entity.
  @MainActor
  public func deleteInstantFile(
    _ entity: InstantFile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteInstantFile(entity.id, callbacks: callbacks)
  }
}

// MARK: - InstantUser Mutations

public extension Shared where Value == IdentifiedArrayOf<InstantUser> {

  // MARK: Create

  /// Create a new InstantUser and sync to InstantDB.
  @MainActor
  public func createInstantUser(
    id: String = UUID().uuidString.lowercased(),
    email: String? = nil,
    imageURL: String? = nil,
    type: String? = nil,
    callbacks: MutationCallbacks<InstantUser> = .init()
  ) {
    callbacks.onMutate?()
    let entity = InstantUser(
      id: id,
      email: email,
      imageURL: imageURL,
      type: type
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the email field of a InstantUser.
  @MainActor
  public func updateEmail(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<InstantUser> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.email = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the imageURL field of a InstantUser.
  @MainActor
  public func updateImageURL(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<InstantUser> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.imageURL = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the type field of a InstantUser.
  @MainActor
  public func updateType(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<InstantUser> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.type = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a InstantUser by ID.
  @MainActor
  public func deleteInstantUser(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a InstantUser entity.
  @MainActor
  public func deleteInstantUser(
    _ entity: InstantUser,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteInstantUser(entity.id, callbacks: callbacks)
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == InstantUser {

  // MARK: Create

  /// Create a new InstantUser and sync to InstantDB.
  @MainActor
  public func createInstantUser(
    id: String = UUID().uuidString.lowercased(),
    email: String? = nil,
    imageURL: String? = nil,
    type: String? = nil,
    callbacks: MutationCallbacks<InstantUser> = .init()
  ) {
    callbacks.onMutate?()
    let entity = InstantUser(
      id: id,
      email: email,
      imageURL: imageURL,
      type: type
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a InstantUser by ID.
  @MainActor
  public func deleteInstantUser(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a InstantUser entity.
  @MainActor
  public func deleteInstantUser(
    _ entity: InstantUser,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteInstantUser(entity.id, callbacks: callbacks)
  }
}

// MARK: - Fact Mutations

public extension Shared where Value == IdentifiedArrayOf<Fact> {

  // MARK: Create

  /// Create a new Fact and sync to InstantDB.
  @MainActor
  public func createFact(
    id: String = UUID().uuidString.lowercased(),
    count: Double,
    text: String,
    callbacks: MutationCallbacks<Fact> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Fact(
      id: id,
      count: count,
      text: text
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the count field of a Fact.
  @MainActor
  public func updateCount(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Fact> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.count = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the count field of a Fact.
  @MainActor
  public func incrementCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Fact> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.count += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the count field of a Fact.
  @MainActor
  public func decrementCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Fact> = .init()
  ) {
    incrementCount(id, by: -amount, callbacks: callbacks)
  }

  /// Update the text field of a Fact.
  @MainActor
  public func updateText(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Fact> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.text = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Fact by ID.
  @MainActor
  public func deleteFact(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Fact entity.
  @MainActor
  public func deleteFact(
    _ entity: Fact,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteFact(entity.id, callbacks: callbacks)
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Fact {

  // MARK: Create

  /// Create a new Fact and sync to InstantDB.
  @MainActor
  public func createFact(
    id: String = UUID().uuidString.lowercased(),
    count: Double,
    text: String,
    callbacks: MutationCallbacks<Fact> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Fact(
      id: id,
      count: count,
      text: text
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Fact by ID.
  @MainActor
  public func deleteFact(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Fact entity.
  @MainActor
  public func deleteFact(
    _ entity: Fact,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteFact(entity.id, callbacks: callbacks)
  }
}

// MARK: - Log Mutations

public extension Shared where Value == IdentifiedArrayOf<Log> {

  // MARK: Create

  /// Create a new Log and sync to InstantDB.
  @MainActor
  public func createLog(
    id: String = UUID().uuidString.lowercased(),
    level: String,
    message: String,
    jsonPayload: String? = nil,
    file: String,
    line: Double,
    timestamp: Double,
    formattedDate: String,
    timezone: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Log(
      id: id,
      level: level,
      message: message,
      jsonPayload: jsonPayload,
      file: file,
      line: line,
      timestamp: timestamp,
      formattedDate: formattedDate,
      timezone: timezone
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the level field of a Log.
  @MainActor
  public func updateLevel(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.level = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the message field of a Log.
  @MainActor
  public func updateMessage(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.message = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the jsonPayload field of a Log.
  @MainActor
  public func updateJsonPayload(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.jsonPayload = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the file field of a Log.
  @MainActor
  public func updateFile(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.file = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the line field of a Log.
  @MainActor
  public func updateLine(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.line = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the timestamp field of a Log.
  @MainActor
  public func updateTimestamp(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.timestamp = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the formattedDate field of a Log.
  @MainActor
  public func updateFormattedDate(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.formattedDate = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the timezone field of a Log.
  @MainActor
  public func updateTimezone(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.timezone = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Log by ID.
  @MainActor
  public func deleteLog(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Log entity.
  @MainActor
  public func deleteLog(
    _ entity: Log,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteLog(entity.id, callbacks: callbacks)
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Log {

  // MARK: Create

  /// Create a new Log and sync to InstantDB.
  @MainActor
  public func createLog(
    id: String = UUID().uuidString.lowercased(),
    level: String,
    message: String,
    jsonPayload: String? = nil,
    file: String,
    line: Double,
    timestamp: Double,
    formattedDate: String,
    timezone: String,
    callbacks: MutationCallbacks<Log> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Log(
      id: id,
      level: level,
      message: message,
      jsonPayload: jsonPayload,
      file: file,
      line: line,
      timestamp: timestamp,
      formattedDate: formattedDate,
      timezone: timezone
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Log by ID.
  @MainActor
  public func deleteLog(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Log entity.
  @MainActor
  public func deleteLog(
    _ entity: Log,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteLog(entity.id, callbacks: callbacks)
  }
}

// MARK: - Todo Mutations

public extension Shared where Value == IdentifiedArrayOf<Todo> {

  // MARK: Create

  /// Create a new Todo and sync to InstantDB.
  @MainActor
  public func createTodo(
    id: String = UUID().uuidString.lowercased(),
    createdAt: Double,
    done: Bool,
    title: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Todo(
      id: id,
      createdAt: createdAt,
      done: done,
      title: title
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Todo.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the done field of a Todo.
  @MainActor
  public func updateDone(
    _ id: String,
    to value: Bool,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.done = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Toggle the done field of a Todo.
  @MainActor
  public func toggleDone(
    _ id: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.done.toggle()
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Set done to true for a Todo.
  @MainActor
  public func markDone(
    _ id: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    updateDone(id, to: true, callbacks: callbacks)
  }

  /// Set done to false for a Todo.
  @MainActor
  public func unmarkDone(
    _ id: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    updateDone(id, to: false, callbacks: callbacks)
  }

  /// Update the title field of a Todo.
  @MainActor
  public func updateTitle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.title = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Todo by ID.
  @MainActor
  public func deleteTodo(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Todo entity.
  @MainActor
  public func deleteTodo(
    _ entity: Todo,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTodo(entity.id, callbacks: callbacks)
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Todo {

  // MARK: Create

  /// Create a new Todo and sync to InstantDB.
  @MainActor
  public func createTodo(
    id: String = UUID().uuidString.lowercased(),
    createdAt: Double,
    done: Bool,
    title: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Todo(
      id: id,
      createdAt: createdAt,
      done: done,
      title: title
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Todo by ID.
  @MainActor
  public func deleteTodo(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Todo entity.
  @MainActor
  public func deleteTodo(
    _ entity: Todo,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTodo(entity.id, callbacks: callbacks)
  }
}

// MARK: - Profile Mutations

public extension Shared where Value == IdentifiedArrayOf<Profile> {

  // MARK: Create

  /// Create a new Profile and sync to InstantDB.
  @MainActor
  public func createProfile(
    id: String = UUID().uuidString.lowercased(),
    displayName: String,
    handle: String,
    bio: String? = nil,
    avatarUrl: String? = nil,
    createdAt: Double,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Profile(
      id: id,
      displayName: displayName,
      handle: handle,
      bio: bio,
      avatarUrl: avatarUrl,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the displayName field of a Profile.
  @MainActor
  public func updateDisplayName(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.displayName = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the handle field of a Profile.
  @MainActor
  public func updateHandle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.handle = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the bio field of a Profile.
  @MainActor
  public func updateBio(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.bio = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the avatarUrl field of a Profile.
  @MainActor
  public func updateAvatarUrl(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.avatarUrl = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Profile.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Profile by ID.
  @MainActor
  public func deleteProfile(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Profile entity.
  @MainActor
  public func deleteProfile(
    _ entity: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteProfile(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Posts

  /// Link a Profile to a Post via 'posts'.
  @MainActor
  public func linkPosts(
    _ id: String,
    to target: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "posts", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Profile from a Post via 'posts'.
  @MainActor
  public func unlinkPosts(
    _ id: String,
    from target: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "posts", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Comments

  /// Link a Profile to a Comment via 'comments'.
  @MainActor
  public func linkComments(
    _ id: String,
    to target: Comment,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "comments", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Profile from a Comment via 'comments'.
  @MainActor
  public func unlinkComments(
    _ id: String,
    from target: Comment,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "comments", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Likes

  /// Link a Profile to a Like via 'likes'.
  @MainActor
  public func linkLikes(
    _ id: String,
    to target: Like,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "likes", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Profile from a Like via 'likes'.
  @MainActor
  public func unlinkLikes(
    _ id: String,
    from target: Like,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "likes", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Profile {

  // MARK: Create

  /// Create a new Profile and sync to InstantDB.
  @MainActor
  public func createProfile(
    id: String = UUID().uuidString.lowercased(),
    displayName: String,
    handle: String,
    bio: String? = nil,
    avatarUrl: String? = nil,
    createdAt: Double,
    callbacks: MutationCallbacks<Profile> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Profile(
      id: id,
      displayName: displayName,
      handle: handle,
      bio: bio,
      avatarUrl: avatarUrl,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Profile by ID.
  @MainActor
  public func deleteProfile(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Profile entity.
  @MainActor
  public func deleteProfile(
    _ entity: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteProfile(entity.id, callbacks: callbacks)
  }
}

// MARK: - Post Mutations

public extension Shared where Value == IdentifiedArrayOf<Post> {

  // MARK: Create

  /// Create a new Post and sync to InstantDB.
  @MainActor
  public func createPost(
    id: String = UUID().uuidString.lowercased(),
    content: String,
    imageUrl: String? = nil,
    createdAt: Double,
    likesCount: Double,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Post(
      id: id,
      content: content,
      imageUrl: imageUrl,
      createdAt: createdAt,
      likesCount: likesCount
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the content field of a Post.
  @MainActor
  public func updateContent(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.content = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the imageUrl field of a Post.
  @MainActor
  public func updateImageUrl(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.imageUrl = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Post.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the likesCount field of a Post.
  @MainActor
  public func updateLikesCount(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.likesCount = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the likesCount field of a Post.
  @MainActor
  public func incrementLikesCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.likesCount += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the likesCount field of a Post.
  @MainActor
  public func decrementLikesCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    incrementLikesCount(id, by: -amount, callbacks: callbacks)
  }

  // MARK: Delete

  /// Delete a Post by ID.
  @MainActor
  public func deletePost(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Post entity.
  @MainActor
  public func deletePost(
    _ entity: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deletePost(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Comments

  /// Link a Post to a Comment via 'comments'.
  @MainActor
  public func linkComments(
    _ id: String,
    to target: Comment,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "comments", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Post from a Comment via 'comments'.
  @MainActor
  public func unlinkComments(
    _ id: String,
    from target: Comment,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "comments", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Likes

  /// Link a Post to a Like via 'likes'.
  @MainActor
  public func linkLikes(
    _ id: String,
    to target: Like,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "likes", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Post from a Like via 'likes'.
  @MainActor
  public func unlinkLikes(
    _ id: String,
    from target: Like,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "likes", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Author

  /// Link a Post to a Profile via 'author'.
  @MainActor
  public func linkAuthor(
    _ id: String,
    to target: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "author", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Post from a Profile via 'author'.
  @MainActor
  public func unlinkAuthor(
    _ id: String,
    from target: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "author", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Post {

  // MARK: Create

  /// Create a new Post and sync to InstantDB.
  @MainActor
  public func createPost(
    id: String = UUID().uuidString.lowercased(),
    content: String,
    imageUrl: String? = nil,
    createdAt: Double,
    likesCount: Double,
    callbacks: MutationCallbacks<Post> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Post(
      id: id,
      content: content,
      imageUrl: imageUrl,
      createdAt: createdAt,
      likesCount: likesCount
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Post by ID.
  @MainActor
  public func deletePost(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Post entity.
  @MainActor
  public func deletePost(
    _ entity: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deletePost(entity.id, callbacks: callbacks)
  }
}

// MARK: - Comment Mutations

public extension Shared where Value == IdentifiedArrayOf<Comment> {

  // MARK: Create

  /// Create a new Comment and sync to InstantDB.
  @MainActor
  public func createComment(
    id: String = UUID().uuidString.lowercased(),
    text: String,
    createdAt: Double,
    callbacks: MutationCallbacks<Comment> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Comment(
      id: id,
      text: text,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the text field of a Comment.
  @MainActor
  public func updateText(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Comment> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.text = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Comment.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Comment> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Comment by ID.
  @MainActor
  public func deleteComment(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Comment entity.
  @MainActor
  public func deleteComment(
    _ entity: Comment,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteComment(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Author

  /// Link a Comment to a Profile via 'author'.
  @MainActor
  public func linkAuthor(
    _ id: String,
    to target: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "author", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Comment from a Profile via 'author'.
  @MainActor
  public func unlinkAuthor(
    _ id: String,
    from target: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "author", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Post

  /// Link a Comment to a Post via 'post'.
  @MainActor
  public func linkPost(
    _ id: String,
    to target: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "post", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Comment from a Post via 'post'.
  @MainActor
  public func unlinkPost(
    _ id: String,
    from target: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "post", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Comment {

  // MARK: Create

  /// Create a new Comment and sync to InstantDB.
  @MainActor
  public func createComment(
    id: String = UUID().uuidString.lowercased(),
    text: String,
    createdAt: Double,
    callbacks: MutationCallbacks<Comment> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Comment(
      id: id,
      text: text,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Comment by ID.
  @MainActor
  public func deleteComment(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Comment entity.
  @MainActor
  public func deleteComment(
    _ entity: Comment,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteComment(entity.id, callbacks: callbacks)
  }
}

// MARK: - Like Mutations

public extension Shared where Value == IdentifiedArrayOf<Like> {

  // MARK: Create

  /// Create a new Like and sync to InstantDB.
  @MainActor
  public func createLike(
    id: String = UUID().uuidString.lowercased(),
    createdAt: Double,
    callbacks: MutationCallbacks<Like> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Like(
      id: id,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Like.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Like> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Like by ID.
  @MainActor
  public func deleteLike(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Like entity.
  @MainActor
  public func deleteLike(
    _ entity: Like,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteLike(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Profile

  /// Link a Like to a Profile via 'profile'.
  @MainActor
  public func linkProfile(
    _ id: String,
    to target: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "profile", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Like from a Profile via 'profile'.
  @MainActor
  public func unlinkProfile(
    _ id: String,
    from target: Profile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "profile", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Post

  /// Link a Like to a Post via 'post'.
  @MainActor
  public func linkPost(
    _ id: String,
    to target: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "post", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Like from a Post via 'post'.
  @MainActor
  public func unlinkPost(
    _ id: String,
    from target: Post,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "post", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Like {

  // MARK: Create

  /// Create a new Like and sync to InstantDB.
  @MainActor
  public func createLike(
    id: String = UUID().uuidString.lowercased(),
    createdAt: Double,
    callbacks: MutationCallbacks<Like> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Like(
      id: id,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Like by ID.
  @MainActor
  public func deleteLike(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Like entity.
  @MainActor
  public func deleteLike(
    _ entity: Like,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteLike(entity.id, callbacks: callbacks)
  }
}

// MARK: - Tile Mutations

public extension Shared where Value == IdentifiedArrayOf<Tile> {

  // MARK: Create

  /// Create a new Tile and sync to InstantDB.
  @MainActor
  public func createTile(
    id: String = UUID().uuidString.lowercased(),
    x: Double,
    y: Double,
    color: String,
    createdAt: Double,
    callbacks: MutationCallbacks<Tile> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Tile(
      id: id,
      x: x,
      y: y,
      color: color,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the x field of a Tile.
  @MainActor
  public func updateX(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Tile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.x = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the y field of a Tile.
  @MainActor
  public func updateY(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Tile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.y = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the color field of a Tile.
  @MainActor
  public func updateColor(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Tile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.color = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Tile.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Tile> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Tile by ID.
  @MainActor
  public func deleteTile(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Tile entity.
  @MainActor
  public func deleteTile(
    _ entity: Tile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTile(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Board

  /// Link a Tile to a Board via 'board'.
  @MainActor
  public func linkBoard(
    _ id: String,
    to target: Board,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "board", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Tile from a Board via 'board'.
  @MainActor
  public func unlinkBoard(
    _ id: String,
    from target: Board,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "board", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Tile {

  // MARK: Create

  /// Create a new Tile and sync to InstantDB.
  @MainActor
  public func createTile(
    id: String = UUID().uuidString.lowercased(),
    x: Double,
    y: Double,
    color: String,
    createdAt: Double,
    callbacks: MutationCallbacks<Tile> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Tile(
      id: id,
      x: x,
      y: y,
      color: color,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Tile by ID.
  @MainActor
  public func deleteTile(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Tile entity.
  @MainActor
  public func deleteTile(
    _ entity: Tile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTile(entity.id, callbacks: callbacks)
  }
}

// MARK: - Board Mutations

public extension Shared where Value == IdentifiedArrayOf<Board> {

  // MARK: Create

  /// Create a new Board and sync to InstantDB.
  @MainActor
  public func createBoard(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    createdAt: Double,
    callbacks: MutationCallbacks<Board> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Board(
      id: id,
      title: title,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the title field of a Board.
  @MainActor
  public func updateTitle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Board> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.title = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a Board.
  @MainActor
  public func updateCreatedAt(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Board> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Board by ID.
  @MainActor
  public func deleteBoard(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Board entity.
  @MainActor
  public func deleteBoard(
    _ entity: Board,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteBoard(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Tiles

  /// Link a Board to a Tile via 'tiles'.
  @MainActor
  public func linkTiles(
    _ id: String,
    to target: Tile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "tiles", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Board from a Tile via 'tiles'.
  @MainActor
  public func unlinkTiles(
    _ id: String,
    from target: Tile,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "tiles", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Board {

  // MARK: Create

  /// Create a new Board and sync to InstantDB.
  @MainActor
  public func createBoard(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    createdAt: Double,
    callbacks: MutationCallbacks<Board> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Board(
      id: id,
      title: title,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Board by ID.
  @MainActor
  public func deleteBoard(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Board entity.
  @MainActor
  public func deleteBoard(
    _ entity: Board,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteBoard(entity.id, callbacks: callbacks)
  }
}

