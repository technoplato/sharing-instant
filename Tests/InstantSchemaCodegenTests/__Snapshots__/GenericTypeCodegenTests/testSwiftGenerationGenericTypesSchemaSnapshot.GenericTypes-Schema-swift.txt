/// ═══════════════════════════════════════════════════════════════════════════════
/// Schema.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file defines the `Schema` namespace containing type-safe `EntityKey`
/// instances for each entity in your InstantDB schema. EntityKeys enable:
/// • Compile-time type safety - no string literals for namespace names
/// • Autocomplete support - `Schema.` shows all available entities
/// • Chainable query modifiers - `.orderBy()`, `.where()`, `.limit()`
/// • Bidirectional sync with `@Shared` or read-only queries with `@SharedReader`
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use `Schema.<entityName>` with `@Shared` for bidirectional sync:
///   @Shared(Schema.tasks)
///   private var items: IdentifiedArrayOf<Task> = []
/// Chain modifiers for ordering, filtering, and limiting:
///   Schema.tasks.orderBy(\.title, .desc)
///   Schema.tasks.where(\.title, .eq("value"))
///   Schema.tasks.limit(10)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct TaskContentView: View {
  /// Bidirectional sync with InstantDB - changes sync automatically!
  @Shared(Schema.tasks.orderBy(\.title, .desc))
  private var items: IdentifiedArrayOf<Task> = []

  @State private var newValue = ""

  var body: some View {
    NavigationStack {
      List {
        Section("Add New") {
          HStack {
            TextField("Enter value", text: $newValue)
            Button("Add") { addItem() }
              .disabled(newValue.isEmpty)
          }
        }

        Section("Items (\(items.count))") {
          ForEach(items) { item in
            Text("\(item.id)")
          }
          .onDelete { indexSet in
            $items.withLock { items in
              for index in indexSet {
                items.remove(at: index)
              }
            }
          }
        }
      }
      .navigationTitle("Tasks")
    }
  }

  private func addItem() {
    // Create and add - syncs automatically!
    let item = Task(/* ... */)
    $items.withLock { $0.append(item) }
    newValue = ""
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Schema.tasks → Task {
///   id: String
///   title: String
///   statusInline: String
///   statusAlias: String
///   priority: String
///   metadataInline: AnyCodable
///   timestamp: AnyCodable
///   speaker: AnyCodable?
/// }
///
/// Schema.media → Media {
///   id: String
///   title: String
///   mediaType: String
///   wordsBracket: AnyCodable
///   wordsGeneric: AnyCodable
///   timestampsInline: AnyCodable
///   speakers: AnyCodable?
/// }
///
/// Schema.transcriptions → Transcription {
///   id: String
///   text: String
///   metadata: AnyCodable
///   segments: AnyCodable
/// }
///

///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import InstantDB
import IdentifiedCollections
import SharingInstant

// MARK: - Schema Namespace

public enum Schema {
  /// Task entity - bidirectional sync
  public static let tasks = EntityKey<Task>(namespace: "tasks")

  /// Media entity - bidirectional sync
  public static let media = EntityKey<Media>(namespace: "media")

  /// Transcription entity - bidirectional sync
  public static let transcriptions = EntityKey<Transcription>(namespace: "transcriptions")

}

// MARK: - Link-Based Where Clause Extensions

public extension EntityKey where Entity == Task {

  /// Filter tasks by their linked Media's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.tasks.whereMedia(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Media to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereMedia(id: String) -> EntityKey<Task> {
    self.where("media.id", .eq(id))
  }

  /// Filter tasks by their linked Media using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.tasks.whereMedia(.eq(someId))
  /// Schema.tasks.whereMedia(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Media's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereMedia(_ predicate: EntityKeyPredicate) -> EntityKey<Task> {
    self.where("media.id", predicate)
  }
}

public extension EntityKey where Entity == Media {

  /// Filter medias by their linked Task's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.media.whereTask(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Task to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereTask(id: String) -> EntityKey<Media> {
    self.where("task.id", .eq(id))
  }

  /// Filter medias by their linked Task using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.media.whereTask(.eq(someId))
  /// Schema.media.whereTask(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Task's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereTask(_ predicate: EntityKeyPredicate) -> EntityKey<Media> {
    self.where("task.id", predicate)
  }

  /// Filter medias by their linked Transcription's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.media.whereTranscription(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Transcription to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscription(id: String) -> EntityKey<Media> {
    self.where("transcription.id", .eq(id))
  }

  /// Filter medias by their linked Transcription using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.media.whereTranscription(.eq(someId))
  /// Schema.media.whereTranscription(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Transcription's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereTranscription(_ predicate: EntityKeyPredicate) -> EntityKey<Media> {
    self.where("transcription.id", predicate)
  }
}

public extension EntityKey where Entity == Transcription {

  /// Filter transcriptions by their linked Media's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.transcriptions.whereMedia(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Media to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereMedia(id: String) -> EntityKey<Transcription> {
    self.where("media.id", .eq(id))
  }

  /// Filter transcriptions by their linked Media using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.transcriptions.whereMedia(.eq(someId))
  /// Schema.transcriptions.whereMedia(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Media's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereMedia(_ predicate: EntityKeyPredicate) -> EntityKey<Transcription> {
    self.where("media.id", predicate)
  }
}

