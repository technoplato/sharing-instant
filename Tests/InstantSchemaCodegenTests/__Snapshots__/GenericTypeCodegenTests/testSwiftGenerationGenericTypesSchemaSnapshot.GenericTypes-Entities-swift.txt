/// ═══════════════════════════════════════════════════════════════════════════════
/// Entities.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains Swift structs for each entity in your InstantDB schema.
/// These structs conform to `EntityIdentifiable`, `Codable`, and `Sendable`,
/// making them ready for use with `@Shared` and `@SharedReader`.
/// Each entity has:
/// • An `id` field (auto-generated UUID by default)
/// • All fields from your schema with proper Swift types
/// • Optional link properties (populated when using `.with()` queries)
/// • A memberwise initializer with sensible defaults
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Create entities using the generated initializers, then add them to
/// synced collections using `$collection.withLock { }`.
/// • Create: `let item = Task(...)`
/// • Add: `$items.withLock { $0.append(item) }`
/// • Update: `$items.withLock { $0[index].field = newValue }`
/// • Delete: `$items.withLock { $0.remove(id: item.id) }`
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct TaskListContentView: View {
  @Shared(Schema.tasks)
  private var items: IdentifiedArrayOf<Task> = []

  var body: some View {
    List {
      ForEach(items) { item in
        Text("\(item.id)")
      }
    }
  }

  private func addItem() {
    let item = Task(
      title: "Title value",
      statusInline: "Statusinline value",
      statusAlias: "Statusalias value",
      priority: "Priority value",
      metadataInline: nil,
      timestamp: nil
    )
    $items.withLock { $0.append(item) }
  }

  private func deleteItem(_ item: Task) {
    $items.withLock { $0.remove(id: item.id) }
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Task {
///   id: String
///   title: String
///   statusInline: String
///   statusAlias: String
///   priority: String
///   metadataInline: AnyCodable
///   timestamp: AnyCodable
///   speaker: AnyCodable?
///   media: [Media]?  // Link (has: many)
/// }
///
/// Media {
///   id: String
///   title: String
///   mediaType: String
///   wordsBracket: AnyCodable
///   wordsGeneric: AnyCodable
///   timestampsInline: AnyCodable
///   speakers: AnyCodable?
///   transcription: Transcription?  // Link (has: one)
///   task: Task?  // Link (has: one)
/// }
///
/// Transcription {
///   id: String
///   text: String
///   metadata: AnyCodable
///   segments: AnyCodable
///   media: Media?  // Link (has: one)
/// }
///

///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import InstantDB
import SharingInstant

/// Generated enum for string union type
public enum TaskStatusInline: String, Codable, Sendable, Equatable {
  case pending
  case active
  case done
}

/// Generated enum for string union type
public enum TaskStatus: String, Codable, Sendable, Equatable {
  case pending
  case inProgress = "in_progress"
  case completed
  case cancelled
}

/// Generated enum for string union type
public enum TaskPriority: String, Codable, Sendable, Equatable {
  case low
  case medium
  case high
  case urgent
}

/// Generated struct for JSON object type
public struct TaskMetadataInline: Codable, Sendable, Equatable {
  public var createdBy: String
  public var version: Double

  public init(
    createdBy: String,
    version: Double
  ) {
    self.createdBy = createdBy
    self.version = version
  }
}

/// Generated struct for JSON object type
public struct Timestamp: Codable, Sendable, Equatable {
  public var start: Double
  public var end: Double

  public init(
    start: Double,
    end: Double
  ) {
    self.start = start
    self.end = end
  }
}

/// Generated struct for JSON object type
public struct Speaker: Codable, Sendable, Equatable {
  public var id: String
  public var name: String
  public var confidence: Double

  public init(
    id: String,
    name: String,
    confidence: Double
  ) {
    self.id = id
    self.name = name
    self.confidence = confidence
  }
}

/// Generated enum for string union type
public enum MediaType: String, Codable, Sendable, Equatable {
  case audio
  case video
  case text
}

/// Generated struct for JSON object type
public struct Word: Codable, Sendable, Equatable {
  public var text: String
  public var start: Double
  public var end: Double
  public var confidence: Double

  public init(
    text: String,
    start: Double,
    end: Double,
    confidence: Double
  ) {
    self.text = text
    self.start = start
    self.end = end
    self.confidence = confidence
  }
}

/// Generated struct for JSON object type
public struct MediaTimestampsInline: Codable, Sendable, Equatable {
  public var start: Double
  public var end: Double

  public init(
    start: Double,
    end: Double
  ) {
    self.start = start
    self.end = end
  }
}

/// Generated struct for JSON object type
public struct TranscriptionMetadata: Codable, Sendable, Equatable {
  public var source: String
  public var language: String
  public var confidence: Double
  public var timestamps: Timestamps

  public init(
    source: String,
    language: String,
    confidence: Double,
    timestamps: Timestamps
  ) {
    self.source = source
    self.language = language
    self.confidence = confidence
    self.timestamps = timestamps
  }
}

/// Generated struct for JSON object type
public struct TranscriptionMetadataTimestamps: Codable, Sendable, Equatable {
  public var start: Double
  public var end: Double

  public init(
    start: Double,
    end: Double
  ) {
    self.start = start
    self.end = end
  }
}

/// Generated struct for JSON object type
public struct TranscriptionSegments: Codable, Sendable, Equatable {
  public var text: String
  public var speaker: Double
  public var start: Double
  public var end: Double

  public init(
    text: String,
    speaker: Double,
    start: Double,
    end: Double
  ) {
    self.text = text
    self.speaker = speaker
    self.start = start
    self.end = end
  }
}

public struct Task: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "tasks" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var statusInline: TaskStatusInline
  public var statusAlias: TaskStatus
  public var priority: TaskPriority
  public var metadataInline: TaskMetadataInline
  public var timestamp: Timestamp
  public var speaker: Speaker?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to media via 'taskMedia'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: [Media]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    statusInline: TaskStatusInline,
    statusAlias: TaskStatus,
    priority: TaskPriority,
    metadataInline: TaskMetadataInline,
    timestamp: Timestamp,
    speaker: Speaker? = nil,
    media: [Media]? = nil
  ) {
    self.id = id
    self.title = title
    self.statusInline = statusInline
    self.statusAlias = statusAlias
    self.priority = priority
    self.metadataInline = metadataInline
    self.timestamp = timestamp
    self.speaker = speaker
    self.media = media
  }
}


public struct Media: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "media" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var mediaType: MediaType
  public var wordsBracket: [Word]
  public var wordsGeneric: [Word]
  public var timestampsInline: [MediaTimestampsInline]
  public var speakers: [Speaker]?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to transcriptions via 'mediaTranscription'
  /// - Note: Only populated when queried with `.with(\.transcription)`
  @IndirectLink
  public var transcription: Transcription?

  /// Link to tasks via 'taskMedia'
  /// - Note: Only populated when queried with `.with(\.task)`
  public var task: Task?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    mediaType: MediaType,
    wordsBracket: [Word],
    wordsGeneric: [Word],
    timestampsInline: [MediaTimestampsInline],
    speakers: [Speaker]? = nil,
    transcription: Transcription? = nil,
    task: Task? = nil
  ) {
    self.id = id
    self.title = title
    self.mediaType = mediaType
    self.wordsBracket = wordsBracket
    self.wordsGeneric = wordsGeneric
    self.timestampsInline = timestampsInline
    self.speakers = speakers
    self.transcription = transcription
    self.task = task
  }
}


public struct Transcription: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "transcriptions" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var text: String
  public var metadata: TranscriptionMetadata
  public var segments: [TranscriptionSegments]

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to media via 'mediaTranscription'
  /// - Note: Only populated when queried with `.with(\.media)`
  @IndirectLink
  public var media: Media?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    text: String,
    metadata: TranscriptionMetadata,
    segments: [TranscriptionSegments],
    media: Media? = nil
  ) {
    self.id = id
    self.text = text
    self.metadata = metadata
    self.segments = segments
    self.media = media
  }
}


