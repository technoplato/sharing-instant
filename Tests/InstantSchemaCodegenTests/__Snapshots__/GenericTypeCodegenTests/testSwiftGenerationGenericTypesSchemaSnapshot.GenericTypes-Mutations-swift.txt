/// ═══════════════════════════════════════════════════════════════════════════════
/// Mutations.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains type-safe mutation extensions for each entity in your
/// InstantDB schema. These methods provide explicit operations (create, update,
/// delete, link, unlink) with TanStack Query-style callbacks.
/// Benefits over withLock mutations:
/// • Explicit operations - no diff computation
/// • Type-safe field updates - compiler catches typos
/// • Semantic methods - toggleDone(), incrementLikes()
/// • Callbacks for success/error handling
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use the generated mutation methods on your @Shared collections:
///   @Shared(Schema.tasks)
///   private var items: IdentifiedArrayOf<Task> = []
///   // Create with all fields
///   $items.createTask(title: value)
///   // Update specific field
///   $items.updateTitle(itemId, to: newValue)
///   // Delete by ID or entity
///   $items.deleteTask(itemId)
///   $items.deleteTask(item)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct TaskMutationsView: View {
  @Shared(Schema.tasks)
  private var items: IdentifiedArrayOf<Task> = []

  var body: some View {
    List(items) { item in
      Text("\(item.id)")
    }
  }

  private func createItem() {
    $items.createTask(
      title: "value",
      callbacks: MutationCallbacks(
        onSuccess: { item in print("Created: \(item.id)") },
        onError: { error in print("Error: \(error)") }
      )
    )
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Task Mutations {
///   createTask(...)
///   updateTitle(_:to:)
///   updateStatusInline(_:to:)
///   updateStatusAlias(_:to:)
///   updatePriority(_:to:)
///   updateMetadataInline(_:to:)
///   updateTimestamp(_:to:)
///   updateSpeaker(_:to:)
///   deleteTask(_:) // by ID
///   deleteTask(_:) // by entity
///   linkMedia(_:to:)
///   unlinkMedia(_:from:)
/// }
///
/// Media Mutations {
///   createMedia(...)
///   updateTitle(_:to:)
///   updateMediaType(_:to:)
///   updateWordsBracket(_:to:)
///   updateWordsGeneric(_:to:)
///   updateTimestampsInline(_:to:)
///   updateSpeakers(_:to:)
///   deleteMedia(_:) // by ID
///   deleteMedia(_:) // by entity
///   linkTranscription(_:to:)
///   unlinkTranscription(_:from:)
///   linkTask(_:to:)
///   unlinkTask(_:from:)
/// }
///
/// Transcription Mutations {
///   createTranscription(...)
///   updateText(_:to:)
///   updateMetadata(_:to:)
///   updateSegments(_:to:)
///   deleteTranscription(_:) // by ID
///   deleteTranscription(_:) // by entity
///   linkMedia(_:to:)
///   unlinkMedia(_:from:)
/// }
///

///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import IdentifiedCollections
import Sharing
import SharingInstant

// MARK: - Task Mutations

public extension Shared where Value == IdentifiedArrayOf<Task> {

  // MARK: Create

  /// Create a new Task and sync to InstantDB.
  @MainActor
  public func createTask(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    statusInline: TaskStatusInline,
    statusAlias: TaskStatus,
    priority: TaskPriority,
    metadataInline: TaskMetadataInline,
    timestamp: Timestamp,
    speaker: Speaker? = nil,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Task(
      id: id,
      title: title,
      statusInline: statusInline,
      statusAlias: statusAlias,
      priority: priority,
      metadataInline: metadataInline,
      timestamp: timestamp,
      speaker: speaker
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the title field of a Task.
  @MainActor
  public func updateTitle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.title = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the statusInline field of a Task.
  @MainActor
  public func updateStatusInline(
    _ id: String,
    to value: TaskStatusInline,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.statusInline = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the statusAlias field of a Task.
  @MainActor
  public func updateStatusAlias(
    _ id: String,
    to value: TaskStatus,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.statusAlias = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the priority field of a Task.
  @MainActor
  public func updatePriority(
    _ id: String,
    to value: TaskPriority,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.priority = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the metadataInline field of a Task.
  @MainActor
  public func updateMetadataInline(
    _ id: String,
    to value: TaskMetadataInline,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.metadataInline = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the timestamp field of a Task.
  @MainActor
  public func updateTimestamp(
    _ id: String,
    to value: Timestamp,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.timestamp = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the speaker field of a Task.
  @MainActor
  public func updateSpeaker(
    _ id: String,
    to value: Speaker?,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.speaker = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Task by ID.
  @MainActor
  public func deleteTask(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Task entity.
  @MainActor
  public func deleteTask(
    _ entity: Task,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTask(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Media

  /// Link a Task to a Media via 'media'.
  @MainActor
  public func linkMedia(
    _ id: String,
    to target: Media,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "media", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Task from a Media via 'media'.
  @MainActor
  public func unlinkMedia(
    _ id: String,
    from target: Media,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "media", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Task {

  // MARK: Create

  /// Create a new Task and sync to InstantDB.
  @MainActor
  public func createTask(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    statusInline: TaskStatusInline,
    statusAlias: TaskStatus,
    priority: TaskPriority,
    metadataInline: TaskMetadataInline,
    timestamp: Timestamp,
    speaker: Speaker? = nil,
    callbacks: MutationCallbacks<Task> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Task(
      id: id,
      title: title,
      statusInline: statusInline,
      statusAlias: statusAlias,
      priority: priority,
      metadataInline: metadataInline,
      timestamp: timestamp,
      speaker: speaker
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Task by ID.
  @MainActor
  public func deleteTask(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Task entity.
  @MainActor
  public func deleteTask(
    _ entity: Task,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTask(entity.id, callbacks: callbacks)
  }
}

// MARK: - Media Mutations

public extension Shared where Value == IdentifiedArrayOf<Media> {

  // MARK: Create

  /// Create a new Media and sync to InstantDB.
  @MainActor
  public func createMedia(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    mediaType: MediaType,
    wordsBracket: [Word],
    wordsGeneric: [Word],
    timestampsInline: [MediaTimestampsInline],
    speakers: [Speaker]? = nil,
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Media(
      id: id,
      title: title,
      mediaType: mediaType,
      wordsBracket: wordsBracket,
      wordsGeneric: wordsGeneric,
      timestampsInline: timestampsInline,
      speakers: speakers
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the title field of a Media.
  @MainActor
  public func updateTitle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.title = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the mediaType field of a Media.
  @MainActor
  public func updateMediaType(
    _ id: String,
    to value: MediaType,
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.mediaType = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the wordsBracket field of a Media.
  @MainActor
  public func updateWordsBracket(
    _ id: String,
    to value: [Word],
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.wordsBracket = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the wordsGeneric field of a Media.
  @MainActor
  public func updateWordsGeneric(
    _ id: String,
    to value: [Word],
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.wordsGeneric = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the timestampsInline field of a Media.
  @MainActor
  public func updateTimestampsInline(
    _ id: String,
    to value: [MediaTimestampsInline],
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.timestampsInline = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the speakers field of a Media.
  @MainActor
  public func updateSpeakers(
    _ id: String,
    to value: [Speaker]?,
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.speakers = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Media by ID.
  @MainActor
  public func deleteMedia(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Media entity.
  @MainActor
  public func deleteMedia(
    _ entity: Media,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteMedia(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Transcription

  /// Link a Media to a Transcription via 'transcription'.
  @MainActor
  public func linkTranscription(
    _ id: String,
    to target: Transcription,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "transcription", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Media from a Transcription via 'transcription'.
  @MainActor
  public func unlinkTranscription(
    _ id: String,
    from target: Transcription,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "transcription", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Task

  /// Link a Media to a Task via 'task'.
  @MainActor
  public func linkTask(
    _ id: String,
    to target: Task,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "task", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Media from a Task via 'task'.
  @MainActor
  public func unlinkTask(
    _ id: String,
    from target: Task,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "task", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Media {

  // MARK: Create

  /// Create a new Media and sync to InstantDB.
  @MainActor
  public func createMedia(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    mediaType: MediaType,
    wordsBracket: [Word],
    wordsGeneric: [Word],
    timestampsInline: [MediaTimestampsInline],
    speakers: [Speaker]? = nil,
    callbacks: MutationCallbacks<Media> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Media(
      id: id,
      title: title,
      mediaType: mediaType,
      wordsBracket: wordsBracket,
      wordsGeneric: wordsGeneric,
      timestampsInline: timestampsInline,
      speakers: speakers
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Media by ID.
  @MainActor
  public func deleteMedia(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Media entity.
  @MainActor
  public func deleteMedia(
    _ entity: Media,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteMedia(entity.id, callbacks: callbacks)
  }
}

// MARK: - Transcription Mutations

public extension Shared where Value == IdentifiedArrayOf<Transcription> {

  // MARK: Create

  /// Create a new Transcription and sync to InstantDB.
  @MainActor
  public func createTranscription(
    id: String = UUID().uuidString.lowercased(),
    text: String,
    metadata: TranscriptionMetadata,
    segments: [TranscriptionSegments],
    callbacks: MutationCallbacks<Transcription> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Transcription(
      id: id,
      text: text,
      metadata: metadata,
      segments: segments
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the text field of a Transcription.
  @MainActor
  public func updateText(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Transcription> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.text = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the metadata field of a Transcription.
  @MainActor
  public func updateMetadata(
    _ id: String,
    to value: TranscriptionMetadata,
    callbacks: MutationCallbacks<Transcription> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.metadata = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the segments field of a Transcription.
  @MainActor
  public func updateSegments(
    _ id: String,
    to value: [TranscriptionSegments],
    callbacks: MutationCallbacks<Transcription> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.segments = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Transcription by ID.
  @MainActor
  public func deleteTranscription(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Transcription entity.
  @MainActor
  public func deleteTranscription(
    _ entity: Transcription,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTranscription(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Media

  /// Link a Transcription to a Media via 'media'.
  @MainActor
  public func linkMedia(
    _ id: String,
    to target: Media,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "media", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Transcription from a Media via 'media'.
  @MainActor
  public func unlinkMedia(
    _ id: String,
    from target: Media,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "media", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Transcription {

  // MARK: Create

  /// Create a new Transcription and sync to InstantDB.
  @MainActor
  public func createTranscription(
    id: String = UUID().uuidString.lowercased(),
    text: String,
    metadata: TranscriptionMetadata,
    segments: [TranscriptionSegments],
    callbacks: MutationCallbacks<Transcription> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Transcription(
      id: id,
      text: text,
      metadata: metadata,
      segments: segments
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Transcription by ID.
  @MainActor
  public func deleteTranscription(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Transcription entity.
  @MainActor
  public func deleteTranscription(
    _ entity: Transcription,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTranscription(entity.id, callbacks: callbacks)
  }
}

