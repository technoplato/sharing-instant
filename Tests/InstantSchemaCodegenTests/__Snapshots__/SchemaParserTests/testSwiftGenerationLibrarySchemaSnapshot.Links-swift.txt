/// ═══════════════════════════════════════════════════════════════════════════════
/// Links.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file defines link metadata for relationships between entities. Links in
/// InstantDB are bidirectional - when you link A to B, B is automatically linked
/// back to A.
/// Links enable:
/// • Type-safe relationship traversal with `.with(\.<linkName>)`
/// • Automatic foreign key management
/// • Cascade delete behavior (when configured)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Include linked entities in your queries using the `.with()` modifier:
///   Schema.authors.with(\.books)
/// Chain multiple links:
///   Schema.authors.with(\.books).with(\.otherLink)
/// The compiler ensures you only request links that actually exist!
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct AuthorWithLinksView: View {
  /// Query authors and include their linked books
  @Shared(Schema.authors.with(\.books))
  private var items: IdentifiedArrayOf<Author> = []

  var body: some View {
    List(items) { item in
      VStack(alignment: .leading, spacing: 8) {
        Text("\(item.id)")
          .font(.headline)

        // Type-safe access to linked entity!
        // This is Optional because the link may not exist
        if let linked = item.books {
          HStack {
            Image(systemName: "link")
            Text("Linked: \(linked.id)")
          }
          .font(.caption)
          .foregroundStyle(.secondary)
        }
      }
      .padding(.vertical, 4)
    }
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// TYPE SAFETY EXAMPLES
///
/// The link system is fully type-safe. The compiler catches errors at build time:
///
/// ✅ COMPILES - books exists on Author:
///    Schema.authors.with(\.books)
///
/// ❌ COMPILE ERROR - "nonexistent" is not a link on Author:
///    Schema.authors.with(\.nonexistent)
///    // Error: Type 'Author' has no member 'nonexistent'
///
///

/// authorBooks {
///   name: "authorBooks"
///
///   forward: {
///     on: Author
///     label: "books"
///     has: many
///   }
///   // Access: Author.books → [Book]?
///
///   reverse: {
///     on: Book
///     label: "author"
///     has: one
///   }
///   // Access: Book.author → Author?
/// }
///
/// bookGenres {
///   name: "bookGenres"
///
///   forward: {
///     on: Book
///     label: "genres"
///     has: many
///   }
///   // Access: Book.genres → [Genre]?
///
///   reverse: {
///     on: Genre
///     label: "books"
///     has: many
///   }
///   // Access: Genre.books → [Book]?
/// }
///
/// bookBorrower {
///   name: "bookBorrower"
///
///   forward: {
///     on: Book
///     label: "currentBorrower"
///     has: one
///   }
///   // Access: Book.currentBorrower → Member?
///
///   reverse: {
///     on: Member
///     label: "borrowedBooks"
///     has: many
///   }
///   // Access: Member.borrowedBooks → [Book]?
/// }
///
/// memberFavoriteAuthor {
///   name: "memberFavoriteAuthor"
///
///   forward: {
///     on: Member
///     label: "favoriteAuthor"
///     has: one
///   }
///   // Access: Member.favoriteAuthor → Author?
///
///   reverse: {
///     on: Author
///     label: "fans"
///     has: many
///   }
///   // Access: Author.fans → [Member]?
/// }
///
/// memberGenreInterests {
///   name: "memberGenreInterests"
///
///   forward: {
///     on: Member
///     label: "genreInterests"
///     has: many
///   }
///   // Access: Member.genreInterests → [Genre]?
///
///   reverse: {
///     on: Genre
///     label: "interestedMembers"
///     has: many
///   }
///   // Access: Genre.interestedMembers → [Member]?
/// }
///
/// borrowRecordBook {
///   name: "borrowRecordBook"
///
///   forward: {
///     on: BorrowRecord
///     label: "book"
///     has: one
///   }
///   // Access: BorrowRecord.book → Book?
///
///   reverse: {
///     on: Book
///     label: "borrowHistory"
///     has: many
///   }
///   // Access: Book.borrowHistory → [BorrowRecord]?
/// }
///
/// borrowRecordMember {
///   name: "borrowRecordMember"
///
///   forward: {
///     on: BorrowRecord
///     label: "member"
///     has: one
///   }
///   // Access: BorrowRecord.member → Member?
///
///   reverse: {
///     on: Member
///     label: "borrowHistory"
///     has: many
///   }
///   // Access: Member.borrowHistory → [BorrowRecord]?
/// }
///
///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import SharingInstant

// MARK: - Link Definitions

public enum SchemaLinks {
  /// authors ↔ books relationship
  /// Author → Books relationship.
An author writes many books.
A book is written by exactly one author.
  public static let authorBooks = Link(
    name: "authorBooks",
    from: Author.self, fromLabel: "books", fromCardinality: .many,
    to: Book.self, toLabel: "author", toCardinality: .one
  )

  /// books ↔ genres relationship
  /// Book ↔ Genre relationship (many-to-many).
A book can belong to multiple genres.
A genre contains many books.
  public static let bookGenres = Link(
    name: "bookGenres",
    from: Book.self, fromLabel: "genres", fromCardinality: .many,
    to: Genre.self, toLabel: "books", toCardinality: .many
  )

  /// books ↔ members relationship
  /// Book → Current Borrower relationship.
A book can be borrowed by at most one member at a time.
A member can borrow multiple books.
  public static let bookBorrower = Link(
    name: "bookBorrower",
    from: Book.self, fromLabel: "currentBorrower", fromCardinality: .one,
    to: Member.self, toLabel: "borrowedBooks", toCardinality: .many
  )

  /// members ↔ authors relationship
  /// Member → Favorite Author relationship.
  public static let memberFavoriteAuthor = Link(
    name: "memberFavoriteAuthor",
    from: Member.self, fromLabel: "favoriteAuthor", fromCardinality: .one,
    to: Author.self, toLabel: "fans", toCardinality: .many
  )

  /// members ↔ genres relationship
  /// Member ↔ Genre Interests (many-to-many).
  public static let memberGenreInterests = Link(
    name: "memberGenreInterests",
    from: Member.self, fromLabel: "genreInterests", fromCardinality: .many,
    to: Genre.self, toLabel: "interestedMembers", toCardinality: .many
  )

  /// borrowRecords ↔ books relationship
  /// Borrow Record → Book relationship.
  public static let borrowRecordBook = Link(
    name: "borrowRecordBook",
    from: BorrowRecord.self, fromLabel: "book", fromCardinality: .one,
    to: Book.self, toLabel: "borrowHistory", toCardinality: .many
  )

  /// borrowRecords ↔ members relationship
  /// Borrow Record → Member relationship.
  public static let borrowRecordMember = Link(
    name: "borrowRecordMember",
    from: BorrowRecord.self, fromLabel: "member", fromCardinality: .one,
    to: Member.self, toLabel: "borrowHistory", toCardinality: .many
  )

}

// MARK: - Link Type

/// Represents a bidirectional link between two entities.
public struct Link<From: InstantEntity, To: InstantEntity>: Sendable {
  public let name: String
  public let fromLabel: String
  public let fromCardinality: LinkCardinality
  public let toLabel: String
  public let toCardinality: LinkCardinality
  
  public init(
    name: String,
    from: From.Type,
    fromLabel: String,
    fromCardinality: LinkCardinality,
    to: To.Type,
    toLabel: String,
    toCardinality: LinkCardinality
  ) {
    self.name = name
    self.fromLabel = fromLabel
    self.fromCardinality = fromCardinality
    self.toLabel = toLabel
    self.toCardinality = toCardinality
  }
}

/// The cardinality of one side of a link.
public enum LinkCardinality: String, Sendable {
  case one
  case many
}
