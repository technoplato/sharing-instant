/// ═══════════════════════════════════════════════════════════════════════════════
/// Entities.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains Swift structs for each entity in your InstantDB schema.
/// These structs conform to `EntityIdentifiable`, `Codable`, and `Sendable`,
/// making them ready for use with `@Shared` and `@SharedReader`.
/// Each entity has:
/// • An `id` field (auto-generated UUID by default)
/// • All fields from your schema with proper Swift types
/// • Optional link properties (populated when using `.with()` queries)
/// • A memberwise initializer with sensible defaults
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Create entities using the generated initializers, then add them to
/// synced collections using `$collection.withLock { }`.
/// • Create: `let item = Member(...)`
/// • Add: `$items.withLock { $0.append(item) }`
/// • Update: `$items.withLock { $0[index].field = newValue }`
/// • Delete: `$items.withLock { $0.remove(id: item.id) }`
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct MemberListContentView: View {
  @Shared(Schema.members)
  private var items: IdentifiedArrayOf<Member> = []

  var body: some View {
    List {
      ForEach(items) { item in
        Text("\(item.id)")
      }
    }
  }

  private func addItem() {
    let item = Member(
      name: "Name value",
      email: "Email value",
      memberSince: Date().timeIntervalSince1970,
      isActive: false,
      currentBorrowCount: Date().timeIntervalSince1970
    )
    $items.withLock { $0.append(item) }
  }

  private func deleteItem(_ item: Member) {
    $items.withLock { $0.remove(id: item.id) }
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Member {
///   id: String
///   name: String
///   email: String
///   memberSince: Date
///   isActive: Bool
///   phoneNumber: String?
///   currentBorrowCount: Double
///   preferences: AnyCodable?
///   favoriteAuthor: Author?  // Link (has: one)
///   genreInterests: [Genre]?  // Link (has: many)
///   borrowedBooks: [Book]?  // Link (has: many)
///   borrowHistory: [BorrowRecord]?  // Link (has: many)
/// }
///
/// Author {
///   id: String
///   name: String
///   bio: String?
///   birthYear: Double?
///   isActive: Bool
///   bookCount: Double
///   books: [Book]?  // Link (has: many)
///   fans: [Member]?  // Link (has: many)
/// }
///
/// Book {
///   id: String
///   title: String
///   isbn: String
///   publicationYear: Double
///   pageCount: Double?
///   description: String?
///   averageRating: Double?
///   availableCopies: Double
///   metadata: AnyCodable?
///   genres: [Genre]?  // Link (has: many)
///   currentBorrower: Member?  // Link (has: one)
///   author: Author?  // Link (has: one)
///   borrowHistory: [BorrowRecord]?  // Link (has: many)
/// }
///
/// Genre {
///   id: String
///   name: String
///   code: String
///   description: String?
///   bookCount: Double
///   books: [Book]?  // Link (has: many)
///   interestedMembers: [Member]?  // Link (has: many)
/// }
///
/// BorrowRecord {
///   id: String
///   borrowedAt: Date
///   dueAt: Date
///   returnedAt: Date?
///   lateFeeInCents: Double?
///   book: Book?  // Link (has: one)
///   member: Member?  // Link (has: one)
/// }
///

///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import InstantDB
import SharingInstant

public struct Member: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "members" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var name: String
  public var email: String
  public var memberSince: Date
  public var isActive: Bool
  public var phoneNumber: String?
  public var currentBorrowCount: Double
  public var preferences: AnyCodable?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to authors via 'memberFavoriteAuthor'
  /// - Note: Only populated when queried with `.with(\.favoriteAuthor)`
  public var favoriteAuthor: Author?

  /// Link to genres via 'memberGenreInterests'
  /// - Note: Only populated when queried with `.with(\.genreInterests)`
  public var genreInterests: [Genre]?

  /// Link to books via 'bookBorrower'
  /// - Note: Only populated when queried with `.with(\.borrowedBooks)`
  public var borrowedBooks: [Book]?

  /// Link to borrowRecords via 'borrowRecordMember'
  /// - Note: Only populated when queried with `.with(\.borrowHistory)`
  public var borrowHistory: [BorrowRecord]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    email: String,
    memberSince: Date,
    isActive: Bool,
    phoneNumber: String? = nil,
    currentBorrowCount: Double,
    preferences: AnyCodable? = nil,
    favoriteAuthor: Author? = nil,
    genreInterests: [Genre]? = nil,
    borrowedBooks: [Book]? = nil,
    borrowHistory: [BorrowRecord]? = nil
  ) {
    self.id = id
    self.name = name
    self.email = email
    self.memberSince = memberSince
    self.isActive = isActive
    self.phoneNumber = phoneNumber
    self.currentBorrowCount = currentBorrowCount
    self.preferences = preferences
    self.favoriteAuthor = favoriteAuthor
    self.genreInterests = genreInterests
    self.borrowedBooks = borrowedBooks
    self.borrowHistory = borrowHistory
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, name, email, memberSince, isActive, phoneNumber, currentBorrowCount, preferences, favoriteAuthor, genreInterests, borrowedBooks, borrowHistory
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.name = try container.decode(String.self, forKey: .name)
    self.email = try container.decode(String.self, forKey: .email)
    self.memberSince = try container.decode(Date.self, forKey: .memberSince)
    self.isActive = try container.decode(FlexibleBool.self, forKey: .isActive).wrappedValue
    self.phoneNumber = try container.decodeIfPresent(String.self, forKey: .phoneNumber)
    self.currentBorrowCount = try container.decode(FlexibleDouble.self, forKey: .currentBorrowCount).wrappedValue
    self.preferences = try container.decodeIfPresent(AnyCodable.self, forKey: .preferences)
    self.favoriteAuthor = try container.decodeIfPresent(Author.self, forKey: .favoriteAuthor)
    self.genreInterests = try container.decodeIfPresent([Genre].self, forKey: .genreInterests)
    self.borrowedBooks = try container.decodeIfPresent([Book].self, forKey: .borrowedBooks)
    self.borrowHistory = try container.decodeIfPresent([BorrowRecord].self, forKey: .borrowHistory)
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(name, forKey: .name)
    try container.encode(email, forKey: .email)
    try container.encode(memberSince, forKey: .memberSince)
    try container.encode(isActive, forKey: .isActive)
    try container.encodeIfPresent(phoneNumber, forKey: .phoneNumber)
    try container.encode(currentBorrowCount, forKey: .currentBorrowCount)
    try container.encodeIfPresent(preferences, forKey: .preferences)
    try container.encodeIfPresent(favoriteAuthor, forKey: .favoriteAuthor)
    try container.encodeIfPresent(genreInterests, forKey: .genreInterests)
    try container.encodeIfPresent(borrowedBooks, forKey: .borrowedBooks)
    try container.encodeIfPresent(borrowHistory, forKey: .borrowHistory)
  }
}


public struct Author: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "authors" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var name: String
  public var bio: String?
  public var birthYear: Double?
  public var isActive: Bool
  public var bookCount: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to books via 'authorBooks'
  /// - Note: Only populated when queried with `.with(\.books)`
  public var books: [Book]?

  /// Link to members via 'memberFavoriteAuthor'
  /// - Note: Only populated when queried with `.with(\.fans)`
  public var fans: [Member]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    bio: String? = nil,
    birthYear: Double? = nil,
    isActive: Bool,
    bookCount: Double,
    books: [Book]? = nil,
    fans: [Member]? = nil
  ) {
    self.id = id
    self.name = name
    self.bio = bio
    self.birthYear = birthYear
    self.isActive = isActive
    self.bookCount = bookCount
    self.books = books
    self.fans = fans
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, name, bio, birthYear, isActive, bookCount, books, fans
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.name = try container.decode(String.self, forKey: .name)
    self.bio = try container.decodeIfPresent(String.self, forKey: .bio)
    if let flexValue = try container.decodeIfPresent(FlexibleDouble.self, forKey: .birthYear) {
      self.birthYear = flexValue.wrappedValue
    } else {
      self.birthYear = nil
    }
    self.isActive = try container.decode(FlexibleBool.self, forKey: .isActive).wrappedValue
    self.bookCount = try container.decode(FlexibleDouble.self, forKey: .bookCount).wrappedValue
    self.books = try container.decodeIfPresent([Book].self, forKey: .books)
    self.fans = try container.decodeIfPresent([Member].self, forKey: .fans)
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(name, forKey: .name)
    try container.encodeIfPresent(bio, forKey: .bio)
    try container.encodeIfPresent(birthYear, forKey: .birthYear)
    try container.encode(isActive, forKey: .isActive)
    try container.encode(bookCount, forKey: .bookCount)
    try container.encodeIfPresent(books, forKey: .books)
    try container.encodeIfPresent(fans, forKey: .fans)
  }
}


public struct Book: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "books" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var isbn: String
  public var publicationYear: Double
  public var pageCount: Double?
  public var description: String?
  public var averageRating: Double?
  public var availableCopies: Double
  public var metadata: AnyCodable?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to genres via 'bookGenres'
  /// - Note: Only populated when queried with `.with(\.genres)`
  public var genres: [Genre]?

  /// Link to members via 'bookBorrower'
  /// - Note: Only populated when queried with `.with(\.currentBorrower)`
  public var currentBorrower: Member?

  /// Link to authors via 'authorBooks'
  /// - Note: Only populated when queried with `.with(\.author)`
  public var author: Author?

  /// Link to borrowRecords via 'borrowRecordBook'
  /// - Note: Only populated when queried with `.with(\.borrowHistory)`
  public var borrowHistory: [BorrowRecord]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    isbn: String,
    publicationYear: Double,
    pageCount: Double? = nil,
    description: String? = nil,
    averageRating: Double? = nil,
    availableCopies: Double,
    metadata: AnyCodable? = nil,
    genres: [Genre]? = nil,
    currentBorrower: Member? = nil,
    author: Author? = nil,
    borrowHistory: [BorrowRecord]? = nil
  ) {
    self.id = id
    self.title = title
    self.isbn = isbn
    self.publicationYear = publicationYear
    self.pageCount = pageCount
    self.description = description
    self.averageRating = averageRating
    self.availableCopies = availableCopies
    self.metadata = metadata
    self.genres = genres
    self.currentBorrower = currentBorrower
    self.author = author
    self.borrowHistory = borrowHistory
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, title, isbn, publicationYear, pageCount, description, averageRating, availableCopies, metadata, genres, currentBorrower, author, borrowHistory
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.title = try container.decode(String.self, forKey: .title)
    self.isbn = try container.decode(String.self, forKey: .isbn)
    self.publicationYear = try container.decode(FlexibleDouble.self, forKey: .publicationYear).wrappedValue
    if let flexValue = try container.decodeIfPresent(FlexibleDouble.self, forKey: .pageCount) {
      self.pageCount = flexValue.wrappedValue
    } else {
      self.pageCount = nil
    }
    self.description = try container.decodeIfPresent(String.self, forKey: .description)
    if let flexValue = try container.decodeIfPresent(FlexibleDouble.self, forKey: .averageRating) {
      self.averageRating = flexValue.wrappedValue
    } else {
      self.averageRating = nil
    }
    self.availableCopies = try container.decode(FlexibleDouble.self, forKey: .availableCopies).wrappedValue
    self.metadata = try container.decodeIfPresent(AnyCodable.self, forKey: .metadata)
    self.genres = try container.decodeIfPresent([Genre].self, forKey: .genres)
    self.currentBorrower = try container.decodeIfPresent(Member.self, forKey: .currentBorrower)
    self.author = try container.decodeIfPresent(Author.self, forKey: .author)
    self.borrowHistory = try container.decodeIfPresent([BorrowRecord].self, forKey: .borrowHistory)
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(title, forKey: .title)
    try container.encode(isbn, forKey: .isbn)
    try container.encode(publicationYear, forKey: .publicationYear)
    try container.encodeIfPresent(pageCount, forKey: .pageCount)
    try container.encodeIfPresent(description, forKey: .description)
    try container.encodeIfPresent(averageRating, forKey: .averageRating)
    try container.encode(availableCopies, forKey: .availableCopies)
    try container.encodeIfPresent(metadata, forKey: .metadata)
    try container.encodeIfPresent(genres, forKey: .genres)
    try container.encodeIfPresent(currentBorrower, forKey: .currentBorrower)
    try container.encodeIfPresent(author, forKey: .author)
    try container.encodeIfPresent(borrowHistory, forKey: .borrowHistory)
  }
}


public struct Genre: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "genres" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var name: String
  public var code: String
  public var description: String?
  public var bookCount: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to books via 'bookGenres'
  /// - Note: Only populated when queried with `.with(\.books)`
  public var books: [Book]?

  /// Link to members via 'memberGenreInterests'
  /// - Note: Only populated when queried with `.with(\.interestedMembers)`
  public var interestedMembers: [Member]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    code: String,
    description: String? = nil,
    bookCount: Double,
    books: [Book]? = nil,
    interestedMembers: [Member]? = nil
  ) {
    self.id = id
    self.name = name
    self.code = code
    self.description = description
    self.bookCount = bookCount
    self.books = books
    self.interestedMembers = interestedMembers
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, name, code, description, bookCount, books, interestedMembers
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.name = try container.decode(String.self, forKey: .name)
    self.code = try container.decode(String.self, forKey: .code)
    self.description = try container.decodeIfPresent(String.self, forKey: .description)
    self.bookCount = try container.decode(FlexibleDouble.self, forKey: .bookCount).wrappedValue
    self.books = try container.decodeIfPresent([Book].self, forKey: .books)
    self.interestedMembers = try container.decodeIfPresent([Member].self, forKey: .interestedMembers)
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(name, forKey: .name)
    try container.encode(code, forKey: .code)
    try container.encodeIfPresent(description, forKey: .description)
    try container.encode(bookCount, forKey: .bookCount)
    try container.encodeIfPresent(books, forKey: .books)
    try container.encodeIfPresent(interestedMembers, forKey: .interestedMembers)
  }
}


public struct BorrowRecord: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "borrowRecords" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var borrowedAt: Date
  public var dueAt: Date
  public var returnedAt: Date?
  public var lateFeeInCents: Double?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to books via 'borrowRecordBook'
  /// - Note: Only populated when queried with `.with(\.book)`
  public var book: Book?

  /// Link to members via 'borrowRecordMember'
  /// - Note: Only populated when queried with `.with(\.member)`
  public var member: Member?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    borrowedAt: Date,
    dueAt: Date,
    returnedAt: Date? = nil,
    lateFeeInCents: Double? = nil,
    book: Book? = nil,
    member: Member? = nil
  ) {
    self.id = id
    self.borrowedAt = borrowedAt
    self.dueAt = dueAt
    self.returnedAt = returnedAt
    self.lateFeeInCents = lateFeeInCents
    self.book = book
    self.member = member
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, borrowedAt, dueAt, returnedAt, lateFeeInCents, book, member
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.borrowedAt = try container.decode(Date.self, forKey: .borrowedAt)
    self.dueAt = try container.decode(Date.self, forKey: .dueAt)
    self.returnedAt = try container.decodeIfPresent(Date.self, forKey: .returnedAt)
    if let flexValue = try container.decodeIfPresent(FlexibleDouble.self, forKey: .lateFeeInCents) {
      self.lateFeeInCents = flexValue.wrappedValue
    } else {
      self.lateFeeInCents = nil
    }
    self.book = try container.decodeIfPresent(Book.self, forKey: .book)
    self.member = try container.decodeIfPresent(Member.self, forKey: .member)
  }

  public func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(borrowedAt, forKey: .borrowedAt)
    try container.encode(dueAt, forKey: .dueAt)
    try container.encodeIfPresent(returnedAt, forKey: .returnedAt)
    try container.encodeIfPresent(lateFeeInCents, forKey: .lateFeeInCents)
    try container.encodeIfPresent(book, forKey: .book)
    try container.encodeIfPresent(member, forKey: .member)
  }
}


