/// ═══════════════════════════════════════════════════════════════════════════════
/// Schema.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file defines the `Schema` namespace containing type-safe `EntityKey`
/// instances for each entity in your InstantDB schema. EntityKeys enable:
/// • Compile-time type safety - no string literals for namespace names
/// • Autocomplete support - `Schema.` shows all available entities
/// • Chainable query modifiers - `.orderBy()`, `.where()`, `.limit()`
/// • Bidirectional sync with `@Shared` or read-only queries with `@SharedReader`
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use `Schema.<entityName>` with `@Shared` for bidirectional sync:
///   @Shared(Schema.members)
///   private var items: IdentifiedArrayOf<Member> = []
/// Chain modifiers for ordering, filtering, and limiting:
///   Schema.members.orderBy(\.name, .desc)
///   Schema.members.where(\.name, .eq("value"))
///   Schema.members.limit(10)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct MemberContentView: View {
  /// Bidirectional sync with InstantDB - changes sync automatically!
  @Shared(Schema.members.orderBy(\.name, .desc))
  private var items: IdentifiedArrayOf<Member> = []

  @State private var newValue = ""

  var body: some View {
    NavigationStack {
      List {
        Section("Add New") {
          HStack {
            TextField("Enter value", text: $newValue)
            Button("Add") { addItem() }
              .disabled(newValue.isEmpty)
          }
        }

        Section("Items (\(items.count))") {
          ForEach(items) { item in
            Text("\(item.id)")
          }
          .onDelete { indexSet in
            $items.withLock { items in
              for index in indexSet {
                items.remove(at: index)
              }
            }
          }
        }
      }
      .navigationTitle("Members")
    }
  }

  private func addItem() {
    // Create and add - syncs automatically!
    let item = Member(/* ... */)
    $items.withLock { $0.append(item) }
    newValue = ""
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Schema.members → Member {
///   id: String
///   name: String
///   email: String
///   memberSince: Date
///   isActive: Bool
///   phoneNumber: String?
///   currentBorrowCount: Double
///   preferences: AnyCodable?
/// }
///
/// Schema.authors → Author {
///   id: String
///   name: String
///   bio: String?
///   birthYear: Double?
///   isActive: Bool
///   bookCount: Double
/// }
///
/// Schema.books → Book {
///   id: String
///   title: String
///   isbn: String
///   publicationYear: Double
///   pageCount: Double?
///   description: String?
///   averageRating: Double?
///   availableCopies: Double
///   metadata: AnyCodable?
/// }
///
/// Schema.genres → Genre {
///   id: String
///   name: String
///   code: String
///   description: String?
///   bookCount: Double
/// }
///
/// Schema.borrowRecords → BorrowRecord {
///   id: String
///   borrowedAt: Date
///   dueAt: Date
///   returnedAt: Date?
///   lateFeeInCents: Double?
/// }
///

///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import InstantDB
import IdentifiedCollections
import SharingInstant

// MARK: - Schema Namespace

public enum Schema {
  /// Member entity - bidirectional sync
  public static let members = EntityKey<Member>(namespace: "members")

  /// Author entity - bidirectional sync
  public static let authors = EntityKey<Author>(namespace: "authors")

  /// Book entity - bidirectional sync
  public static let books = EntityKey<Book>(namespace: "books")

  /// Genre entity - bidirectional sync
  public static let genres = EntityKey<Genre>(namespace: "genres")

  /// BorrowRecord entity - bidirectional sync
  public static let borrowRecords = EntityKey<BorrowRecord>(namespace: "borrowRecords")

}

// MARK: - Link-Based Where Clause Extensions

public extension EntityKey where Entity == Member {

  /// Filter members by their linked Book's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.members.whereBorrowedBooks(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Book to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBorrowedBooks(id: String) -> EntityKey<Member> {
    self.where("borrowedBooks.id", .eq(id))
  }

  /// Filter members by their linked Book using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.members.whereBorrowedBooks(.eq(someId))
  /// Schema.members.whereBorrowedBooks(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Book's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBorrowedBooks(_ predicate: EntityKeyPredicate) -> EntityKey<Member> {
    self.where("borrowedBooks.id", predicate)
  }

  /// Filter members by their linked Author's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.members.whereFavoriteAuthor(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Author to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereFavoriteAuthor(id: String) -> EntityKey<Member> {
    self.where("favoriteAuthor.id", .eq(id))
  }

  /// Filter members by their linked Author using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.members.whereFavoriteAuthor(.eq(someId))
  /// Schema.members.whereFavoriteAuthor(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Author's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereFavoriteAuthor(_ predicate: EntityKeyPredicate) -> EntityKey<Member> {
    self.where("favoriteAuthor.id", predicate)
  }

  /// Filter members by their linked Genre's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.members.whereGenreInterests(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Genre to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereGenreInterests(id: String) -> EntityKey<Member> {
    self.where("genreInterests.id", .eq(id))
  }

  /// Filter members by their linked Genre using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.members.whereGenreInterests(.eq(someId))
  /// Schema.members.whereGenreInterests(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Genre's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereGenreInterests(_ predicate: EntityKeyPredicate) -> EntityKey<Member> {
    self.where("genreInterests.id", predicate)
  }

  /// Filter members by their linked BorrowRecord's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.members.whereBorrowHistory(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked BorrowRecord to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBorrowHistory(id: String) -> EntityKey<Member> {
    self.where("borrowHistory.id", .eq(id))
  }

  /// Filter members by their linked BorrowRecord using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.members.whereBorrowHistory(.eq(someId))
  /// Schema.members.whereBorrowHistory(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked BorrowRecord's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBorrowHistory(_ predicate: EntityKeyPredicate) -> EntityKey<Member> {
    self.where("borrowHistory.id", predicate)
  }
}

public extension EntityKey where Entity == Author {

  /// Filter authors by their linked Book's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.authors.whereBooks(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Book to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBooks(id: String) -> EntityKey<Author> {
    self.where("books.id", .eq(id))
  }

  /// Filter authors by their linked Book using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.authors.whereBooks(.eq(someId))
  /// Schema.authors.whereBooks(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Book's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBooks(_ predicate: EntityKeyPredicate) -> EntityKey<Author> {
    self.where("books.id", predicate)
  }

  /// Filter authors by their linked Member's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.authors.whereFans(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Member to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereFans(id: String) -> EntityKey<Author> {
    self.where("fans.id", .eq(id))
  }

  /// Filter authors by their linked Member using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.authors.whereFans(.eq(someId))
  /// Schema.authors.whereFans(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Member's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereFans(_ predicate: EntityKeyPredicate) -> EntityKey<Author> {
    self.where("fans.id", predicate)
  }
}

public extension EntityKey where Entity == Book {

  /// Filter books by their linked Author's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.books.whereAuthor(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Author to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereAuthor(id: String) -> EntityKey<Book> {
    self.where("author.id", .eq(id))
  }

  /// Filter books by their linked Author using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.books.whereAuthor(.eq(someId))
  /// Schema.books.whereAuthor(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Author's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereAuthor(_ predicate: EntityKeyPredicate) -> EntityKey<Book> {
    self.where("author.id", predicate)
  }

  /// Filter books by their linked Genre's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.books.whereGenres(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Genre to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereGenres(id: String) -> EntityKey<Book> {
    self.where("genres.id", .eq(id))
  }

  /// Filter books by their linked Genre using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.books.whereGenres(.eq(someId))
  /// Schema.books.whereGenres(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Genre's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereGenres(_ predicate: EntityKeyPredicate) -> EntityKey<Book> {
    self.where("genres.id", predicate)
  }

  /// Filter books by their linked Member's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.books.whereCurrentBorrower(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Member to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereCurrentBorrower(id: String) -> EntityKey<Book> {
    self.where("currentBorrower.id", .eq(id))
  }

  /// Filter books by their linked Member using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.books.whereCurrentBorrower(.eq(someId))
  /// Schema.books.whereCurrentBorrower(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Member's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereCurrentBorrower(_ predicate: EntityKeyPredicate) -> EntityKey<Book> {
    self.where("currentBorrower.id", predicate)
  }

  /// Filter books by their linked BorrowRecord's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.books.whereBorrowHistory(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked BorrowRecord to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBorrowHistory(id: String) -> EntityKey<Book> {
    self.where("borrowHistory.id", .eq(id))
  }

  /// Filter books by their linked BorrowRecord using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.books.whereBorrowHistory(.eq(someId))
  /// Schema.books.whereBorrowHistory(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked BorrowRecord's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBorrowHistory(_ predicate: EntityKeyPredicate) -> EntityKey<Book> {
    self.where("borrowHistory.id", predicate)
  }
}

public extension EntityKey where Entity == Genre {

  /// Filter genres by their linked Book's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.genres.whereBooks(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Book to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBooks(id: String) -> EntityKey<Genre> {
    self.where("books.id", .eq(id))
  }

  /// Filter genres by their linked Book using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.genres.whereBooks(.eq(someId))
  /// Schema.genres.whereBooks(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Book's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBooks(_ predicate: EntityKeyPredicate) -> EntityKey<Genre> {
    self.where("books.id", predicate)
  }

  /// Filter genres by their linked Member's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.genres.whereInterestedMembers(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Member to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereInterestedMembers(id: String) -> EntityKey<Genre> {
    self.where("interestedMembers.id", .eq(id))
  }

  /// Filter genres by their linked Member using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.genres.whereInterestedMembers(.eq(someId))
  /// Schema.genres.whereInterestedMembers(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Member's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereInterestedMembers(_ predicate: EntityKeyPredicate) -> EntityKey<Genre> {
    self.where("interestedMembers.id", predicate)
  }
}

public extension EntityKey where Entity == BorrowRecord {

  /// Filter borrowrecords by their linked Book's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.borrowRecords.whereBook(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Book to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereBook(id: String) -> EntityKey<BorrowRecord> {
    self.where("book.id", .eq(id))
  }

  /// Filter borrowrecords by their linked Book using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.borrowRecords.whereBook(.eq(someId))
  /// Schema.borrowRecords.whereBook(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Book's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereBook(_ predicate: EntityKeyPredicate) -> EntityKey<BorrowRecord> {
    self.where("book.id", predicate)
  }

  /// Filter borrowrecords by their linked Member's ID.
  ///
  /// This enables type-safe filtering by linked entity relationships:
  /// ```swift
  /// Schema.borrowRecords.whereMember(id: someId)
  /// ```
  ///
  /// - Parameter id: The ID of the linked Member to filter by
  /// - Returns: A new EntityKey with the filter applied
  func whereMember(id: String) -> EntityKey<BorrowRecord> {
    self.where("member.id", .eq(id))
  }

  /// Filter borrowrecords by their linked Member using a predicate.
  ///
  /// This enables flexible filtering using various predicates:
  /// ```swift
  /// Schema.borrowRecords.whereMember(.eq(someId))
  /// Schema.borrowRecords.whereMember(.in([id1, id2]))
  /// ```
  ///
  /// - Parameter predicate: The predicate to apply to the linked Member's ID
  /// - Returns: A new EntityKey with the filter applied
  func whereMember(_ predicate: EntityKeyPredicate) -> EntityKey<BorrowRecord> {
    self.where("member.id", predicate)
  }
}

