/// ═══════════════════════════════════════════════════════════════════════════════
/// Mutations.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains type-safe mutation extensions for each entity in your
/// InstantDB schema. These methods provide explicit operations (create, update,
/// delete, link, unlink) with TanStack Query-style callbacks.
/// Benefits over withLock mutations:
/// • Explicit operations - no diff computation
/// • Type-safe field updates - compiler catches typos
/// • Semantic methods - toggleDone(), incrementLikes()
/// • Callbacks for success/error handling
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use the generated mutation methods on your @Shared collections:
///   @Shared(Schema.members)
///   private var items: IdentifiedArrayOf<Member> = []
///   // Create with all fields
///   $items.createMember(name: value)
///   // Update specific field
///   $items.updateName(itemId, to: newValue)
///   // Delete by ID or entity
///   $items.deleteMember(itemId)
///   $items.deleteMember(item)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct MemberMutationsView: View {
  @Shared(Schema.members)
  private var items: IdentifiedArrayOf<Member> = []

  var body: some View {
    List(items) { item in
      Text("\(item.id)")
    }
  }

  private func createItem() {
    $items.createMember(
      name: "value",
      callbacks: MutationCallbacks(
        onSuccess: { item in print("Created: \(item.id)") },
        onError: { error in print("Error: \(error)") }
      )
    )
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Member Mutations {
///   createMember(...)
///   updateName(_:to:)
///   updateEmail(_:to:)
///   updateMemberSince(_:to:)
///   updateIsActive(_:to:)
///   toggleIsActive(_:)
///   markIsActive(_:)
///   unmarkIsActive(_:)
///   updatePhoneNumber(_:to:)
///   updateCurrentBorrowCount(_:to:)
///   incrementCurrentBorrowCount(_:by:)
///   decrementCurrentBorrowCount(_:by:)
///   updatePreferences(_:to:)
///   deleteMember(_:) // by ID
///   deleteMember(_:) // by entity
///   linkFavoriteAuthor(_:to:)
///   unlinkFavoriteAuthor(_:from:)
///   linkGenreInterests(_:to:)
///   unlinkGenreInterests(_:from:)
///   linkBorrowedBooks(_:to:)
///   unlinkBorrowedBooks(_:from:)
///   linkBorrowHistory(_:to:)
///   unlinkBorrowHistory(_:from:)
/// }
///
/// Author Mutations {
///   createAuthor(...)
///   updateName(_:to:)
///   updateBio(_:to:)
///   updateBirthYear(_:to:)
///   updateIsActive(_:to:)
///   toggleIsActive(_:)
///   markIsActive(_:)
///   unmarkIsActive(_:)
///   updateBookCount(_:to:)
///   incrementBookCount(_:by:)
///   decrementBookCount(_:by:)
///   deleteAuthor(_:) // by ID
///   deleteAuthor(_:) // by entity
///   linkBooks(_:to:)
///   unlinkBooks(_:from:)
///   linkFans(_:to:)
///   unlinkFans(_:from:)
/// }
///
/// Book Mutations {
///   createBook(...)
///   updateTitle(_:to:)
///   updateIsbn(_:to:)
///   updatePublicationYear(_:to:)
///   updatePageCount(_:to:)
///   incrementPageCount(_:by:)
///   decrementPageCount(_:by:)
///   updateDescription(_:to:)
///   updateAverageRating(_:to:)
///   updateAvailableCopies(_:to:)
///   incrementAvailableCopies(_:by:)
///   decrementAvailableCopies(_:by:)
///   updateMetadata(_:to:)
///   deleteBook(_:) // by ID
///   deleteBook(_:) // by entity
///   linkGenres(_:to:)
///   unlinkGenres(_:from:)
///   linkCurrentBorrower(_:to:)
///   unlinkCurrentBorrower(_:from:)
///   linkAuthor(_:to:)
///   unlinkAuthor(_:from:)
///   linkBorrowHistory(_:to:)
///   unlinkBorrowHistory(_:from:)
/// }
///
/// Genre Mutations {
///   createGenre(...)
///   updateName(_:to:)
///   updateCode(_:to:)
///   updateDescription(_:to:)
///   updateBookCount(_:to:)
///   incrementBookCount(_:by:)
///   decrementBookCount(_:by:)
///   deleteGenre(_:) // by ID
///   deleteGenre(_:) // by entity
///   linkBooks(_:to:)
///   unlinkBooks(_:from:)
///   linkInterestedMembers(_:to:)
///   unlinkInterestedMembers(_:from:)
/// }
///
/// BorrowRecord Mutations {
///   createBorrowRecord(...)
///   updateBorrowedAt(_:to:)
///   updateDueAt(_:to:)
///   updateReturnedAt(_:to:)
///   updateLateFeeInCents(_:to:)
///   incrementLateFeeInCents(_:by:)
///   decrementLateFeeInCents(_:by:)
///   deleteBorrowRecord(_:) // by ID
///   deleteBorrowRecord(_:) // by entity
///   linkBook(_:to:)
///   unlinkBook(_:from:)
///   linkMember(_:to:)
///   unlinkMember(_:from:)
/// }
///

///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import IdentifiedCollections
import Sharing
import SharingInstant

// MARK: - Member Mutations

public extension Shared where Value == IdentifiedArrayOf<Member> {

  // MARK: Create

  /// Create a new Member and sync to InstantDB.
  @MainActor
  public func createMember(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    email: String,
    memberSince: Date,
    isActive: Bool,
    phoneNumber: String? = nil,
    currentBorrowCount: Double,
    preferences: AnyCodable? = nil,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Member(
      id: id,
      name: name,
      email: email,
      memberSince: memberSince,
      isActive: isActive,
      phoneNumber: phoneNumber,
      currentBorrowCount: currentBorrowCount,
      preferences: preferences
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the name field of a Member.
  @MainActor
  public func updateName(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.name = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the email field of a Member.
  @MainActor
  public func updateEmail(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.email = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the memberSince field of a Member.
  @MainActor
  public func updateMemberSince(
    _ id: String,
    to value: Date,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.memberSince = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the isActive field of a Member.
  @MainActor
  public func updateIsActive(
    _ id: String,
    to value: Bool,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.isActive = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Toggle the isActive field of a Member.
  @MainActor
  public func toggleIsActive(
    _ id: String,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.isActive.toggle()
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Set isActive to true for a Member.
  @MainActor
  public func markIsActive(
    _ id: String,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    updateIsActive(id, to: true, callbacks: callbacks)
  }

  /// Set isActive to false for a Member.
  @MainActor
  public func unmarkIsActive(
    _ id: String,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    updateIsActive(id, to: false, callbacks: callbacks)
  }

  /// Update the phoneNumber field of a Member.
  @MainActor
  public func updatePhoneNumber(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.phoneNumber = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the currentBorrowCount field of a Member.
  @MainActor
  public func updateCurrentBorrowCount(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.currentBorrowCount = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the currentBorrowCount field of a Member.
  @MainActor
  public func incrementCurrentBorrowCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.currentBorrowCount += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the currentBorrowCount field of a Member.
  @MainActor
  public func decrementCurrentBorrowCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    incrementCurrentBorrowCount(id, by: -amount, callbacks: callbacks)
  }

  /// Update the preferences field of a Member.
  @MainActor
  public func updatePreferences(
    _ id: String,
    to value: AnyCodable?,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.preferences = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Member by ID.
  @MainActor
  public func deleteMember(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Member entity.
  @MainActor
  public func deleteMember(
    _ entity: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteMember(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink FavoriteAuthor

  /// Link a Member to a Author via 'favoriteAuthor'.
  @MainActor
  public func linkFavoriteAuthor(
    _ id: String,
    to target: Author,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "favoriteAuthor", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Member from a Author via 'favoriteAuthor'.
  @MainActor
  public func unlinkFavoriteAuthor(
    _ id: String,
    from target: Author,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "favoriteAuthor", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink GenreInterests

  /// Link a Member to a Genre via 'genreInterests'.
  @MainActor
  public func linkGenreInterests(
    _ id: String,
    to target: Genre,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "genreInterests", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Member from a Genre via 'genreInterests'.
  @MainActor
  public func unlinkGenreInterests(
    _ id: String,
    from target: Genre,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "genreInterests", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink BorrowedBooks

  /// Link a Member to a Book via 'borrowedBooks'.
  @MainActor
  public func linkBorrowedBooks(
    _ id: String,
    to target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "borrowedBooks", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Member from a Book via 'borrowedBooks'.
  @MainActor
  public func unlinkBorrowedBooks(
    _ id: String,
    from target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "borrowedBooks", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink BorrowHistory

  /// Link a Member to a BorrowRecord via 'borrowHistory'.
  @MainActor
  public func linkBorrowHistory(
    _ id: String,
    to target: BorrowRecord,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "borrowHistory", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Member from a BorrowRecord via 'borrowHistory'.
  @MainActor
  public func unlinkBorrowHistory(
    _ id: String,
    from target: BorrowRecord,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "borrowHistory", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Member {

  // MARK: Create

  /// Create a new Member and sync to InstantDB.
  @MainActor
  public func createMember(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    email: String,
    memberSince: Date,
    isActive: Bool,
    phoneNumber: String? = nil,
    currentBorrowCount: Double,
    preferences: AnyCodable? = nil,
    callbacks: MutationCallbacks<Member> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Member(
      id: id,
      name: name,
      email: email,
      memberSince: memberSince,
      isActive: isActive,
      phoneNumber: phoneNumber,
      currentBorrowCount: currentBorrowCount,
      preferences: preferences
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Member by ID.
  @MainActor
  public func deleteMember(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Member entity.
  @MainActor
  public func deleteMember(
    _ entity: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteMember(entity.id, callbacks: callbacks)
  }
}

// MARK: - Author Mutations

public extension Shared where Value == IdentifiedArrayOf<Author> {

  // MARK: Create

  /// Create a new Author and sync to InstantDB.
  @MainActor
  public func createAuthor(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    bio: String? = nil,
    birthYear: Double? = nil,
    isActive: Bool,
    bookCount: Double,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Author(
      id: id,
      name: name,
      bio: bio,
      birthYear: birthYear,
      isActive: isActive,
      bookCount: bookCount
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the name field of a Author.
  @MainActor
  public func updateName(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.name = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the bio field of a Author.
  @MainActor
  public func updateBio(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.bio = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the birthYear field of a Author.
  @MainActor
  public func updateBirthYear(
    _ id: String,
    to value: Double?,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.birthYear = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the isActive field of a Author.
  @MainActor
  public func updateIsActive(
    _ id: String,
    to value: Bool,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.isActive = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Toggle the isActive field of a Author.
  @MainActor
  public func toggleIsActive(
    _ id: String,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.isActive.toggle()
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Set isActive to true for a Author.
  @MainActor
  public func markIsActive(
    _ id: String,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    updateIsActive(id, to: true, callbacks: callbacks)
  }

  /// Set isActive to false for a Author.
  @MainActor
  public func unmarkIsActive(
    _ id: String,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    updateIsActive(id, to: false, callbacks: callbacks)
  }

  /// Update the bookCount field of a Author.
  @MainActor
  public func updateBookCount(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.bookCount = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the bookCount field of a Author.
  @MainActor
  public func incrementBookCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.bookCount += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the bookCount field of a Author.
  @MainActor
  public func decrementBookCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    incrementBookCount(id, by: -amount, callbacks: callbacks)
  }

  // MARK: Delete

  /// Delete a Author by ID.
  @MainActor
  public func deleteAuthor(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Author entity.
  @MainActor
  public func deleteAuthor(
    _ entity: Author,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteAuthor(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Books

  /// Link a Author to a Book via 'books'.
  @MainActor
  public func linkBooks(
    _ id: String,
    to target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "books", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Author from a Book via 'books'.
  @MainActor
  public func unlinkBooks(
    _ id: String,
    from target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "books", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Fans

  /// Link a Author to a Member via 'fans'.
  @MainActor
  public func linkFans(
    _ id: String,
    to target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "fans", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Author from a Member via 'fans'.
  @MainActor
  public func unlinkFans(
    _ id: String,
    from target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "fans", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Author {

  // MARK: Create

  /// Create a new Author and sync to InstantDB.
  @MainActor
  public func createAuthor(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    bio: String? = nil,
    birthYear: Double? = nil,
    isActive: Bool,
    bookCount: Double,
    callbacks: MutationCallbacks<Author> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Author(
      id: id,
      name: name,
      bio: bio,
      birthYear: birthYear,
      isActive: isActive,
      bookCount: bookCount
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Author by ID.
  @MainActor
  public func deleteAuthor(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Author entity.
  @MainActor
  public func deleteAuthor(
    _ entity: Author,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteAuthor(entity.id, callbacks: callbacks)
  }
}

// MARK: - Book Mutations

public extension Shared where Value == IdentifiedArrayOf<Book> {

  // MARK: Create

  /// Create a new Book and sync to InstantDB.
  @MainActor
  public func createBook(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    isbn: String,
    publicationYear: Double,
    pageCount: Double? = nil,
    description: String? = nil,
    averageRating: Double? = nil,
    availableCopies: Double,
    metadata: AnyCodable? = nil,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Book(
      id: id,
      title: title,
      isbn: isbn,
      publicationYear: publicationYear,
      pageCount: pageCount,
      description: description,
      averageRating: averageRating,
      availableCopies: availableCopies,
      metadata: metadata
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the title field of a Book.
  @MainActor
  public func updateTitle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.title = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the isbn field of a Book.
  @MainActor
  public func updateIsbn(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.isbn = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the publicationYear field of a Book.
  @MainActor
  public func updatePublicationYear(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.publicationYear = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the pageCount field of a Book.
  @MainActor
  public func updatePageCount(
    _ id: String,
    to value: Double?,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.pageCount = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the pageCount field of a Book.
  @MainActor
  public func incrementPageCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.pageCount += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the pageCount field of a Book.
  @MainActor
  public func decrementPageCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    incrementPageCount(id, by: -amount, callbacks: callbacks)
  }

  /// Update the description field of a Book.
  @MainActor
  public func updateDescription(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.description = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the averageRating field of a Book.
  @MainActor
  public func updateAverageRating(
    _ id: String,
    to value: Double?,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.averageRating = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the availableCopies field of a Book.
  @MainActor
  public func updateAvailableCopies(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.availableCopies = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the availableCopies field of a Book.
  @MainActor
  public func incrementAvailableCopies(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.availableCopies += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the availableCopies field of a Book.
  @MainActor
  public func decrementAvailableCopies(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    incrementAvailableCopies(id, by: -amount, callbacks: callbacks)
  }

  /// Update the metadata field of a Book.
  @MainActor
  public func updateMetadata(
    _ id: String,
    to value: AnyCodable?,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.metadata = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Book by ID.
  @MainActor
  public func deleteBook(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Book entity.
  @MainActor
  public func deleteBook(
    _ entity: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteBook(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Genres

  /// Link a Book to a Genre via 'genres'.
  @MainActor
  public func linkGenres(
    _ id: String,
    to target: Genre,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "genres", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Book from a Genre via 'genres'.
  @MainActor
  public func unlinkGenres(
    _ id: String,
    from target: Genre,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "genres", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink CurrentBorrower

  /// Link a Book to a Member via 'currentBorrower'.
  @MainActor
  public func linkCurrentBorrower(
    _ id: String,
    to target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "currentBorrower", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Book from a Member via 'currentBorrower'.
  @MainActor
  public func unlinkCurrentBorrower(
    _ id: String,
    from target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "currentBorrower", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Author

  /// Link a Book to a Author via 'author'.
  @MainActor
  public func linkAuthor(
    _ id: String,
    to target: Author,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "author", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Book from a Author via 'author'.
  @MainActor
  public func unlinkAuthor(
    _ id: String,
    from target: Author,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "author", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink BorrowHistory

  /// Link a Book to a BorrowRecord via 'borrowHistory'.
  @MainActor
  public func linkBorrowHistory(
    _ id: String,
    to target: BorrowRecord,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "borrowHistory", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Book from a BorrowRecord via 'borrowHistory'.
  @MainActor
  public func unlinkBorrowHistory(
    _ id: String,
    from target: BorrowRecord,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "borrowHistory", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Book {

  // MARK: Create

  /// Create a new Book and sync to InstantDB.
  @MainActor
  public func createBook(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    isbn: String,
    publicationYear: Double,
    pageCount: Double? = nil,
    description: String? = nil,
    averageRating: Double? = nil,
    availableCopies: Double,
    metadata: AnyCodable? = nil,
    callbacks: MutationCallbacks<Book> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Book(
      id: id,
      title: title,
      isbn: isbn,
      publicationYear: publicationYear,
      pageCount: pageCount,
      description: description,
      averageRating: averageRating,
      availableCopies: availableCopies,
      metadata: metadata
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Book by ID.
  @MainActor
  public func deleteBook(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Book entity.
  @MainActor
  public func deleteBook(
    _ entity: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteBook(entity.id, callbacks: callbacks)
  }
}

// MARK: - Genre Mutations

public extension Shared where Value == IdentifiedArrayOf<Genre> {

  // MARK: Create

  /// Create a new Genre and sync to InstantDB.
  @MainActor
  public func createGenre(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    code: String,
    description: String? = nil,
    bookCount: Double,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Genre(
      id: id,
      name: name,
      code: code,
      description: description,
      bookCount: bookCount
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the name field of a Genre.
  @MainActor
  public func updateName(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.name = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the code field of a Genre.
  @MainActor
  public func updateCode(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.code = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the description field of a Genre.
  @MainActor
  public func updateDescription(
    _ id: String,
    to value: String?,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.description = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the bookCount field of a Genre.
  @MainActor
  public func updateBookCount(
    _ id: String,
    to value: Double,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.bookCount = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the bookCount field of a Genre.
  @MainActor
  public func incrementBookCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.bookCount += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the bookCount field of a Genre.
  @MainActor
  public func decrementBookCount(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    incrementBookCount(id, by: -amount, callbacks: callbacks)
  }

  // MARK: Delete

  /// Delete a Genre by ID.
  @MainActor
  public func deleteGenre(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Genre entity.
  @MainActor
  public func deleteGenre(
    _ entity: Genre,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteGenre(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Books

  /// Link a Genre to a Book via 'books'.
  @MainActor
  public func linkBooks(
    _ id: String,
    to target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "books", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Genre from a Book via 'books'.
  @MainActor
  public func unlinkBooks(
    _ id: String,
    from target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "books", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink InterestedMembers

  /// Link a Genre to a Member via 'interestedMembers'.
  @MainActor
  public func linkInterestedMembers(
    _ id: String,
    to target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "interestedMembers", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Genre from a Member via 'interestedMembers'.
  @MainActor
  public func unlinkInterestedMembers(
    _ id: String,
    from target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "interestedMembers", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Genre {

  // MARK: Create

  /// Create a new Genre and sync to InstantDB.
  @MainActor
  public func createGenre(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    code: String,
    description: String? = nil,
    bookCount: Double,
    callbacks: MutationCallbacks<Genre> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Genre(
      id: id,
      name: name,
      code: code,
      description: description,
      bookCount: bookCount
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Genre by ID.
  @MainActor
  public func deleteGenre(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Genre entity.
  @MainActor
  public func deleteGenre(
    _ entity: Genre,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteGenre(entity.id, callbacks: callbacks)
  }
}

// MARK: - BorrowRecord Mutations

public extension Shared where Value == IdentifiedArrayOf<BorrowRecord> {

  // MARK: Create

  /// Create a new BorrowRecord and sync to InstantDB.
  @MainActor
  public func createBorrowRecord(
    id: String = UUID().uuidString.lowercased(),
    borrowedAt: Date,
    dueAt: Date,
    returnedAt: Date? = nil,
    lateFeeInCents: Double? = nil,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    let entity = BorrowRecord(
      id: id,
      borrowedAt: borrowedAt,
      dueAt: dueAt,
      returnedAt: returnedAt,
      lateFeeInCents: lateFeeInCents
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the borrowedAt field of a BorrowRecord.
  @MainActor
  public func updateBorrowedAt(
    _ id: String,
    to value: Date,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.borrowedAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the dueAt field of a BorrowRecord.
  @MainActor
  public func updateDueAt(
    _ id: String,
    to value: Date,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.dueAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the returnedAt field of a BorrowRecord.
  @MainActor
  public func updateReturnedAt(
    _ id: String,
    to value: Date?,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.returnedAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the lateFeeInCents field of a BorrowRecord.
  @MainActor
  public func updateLateFeeInCents(
    _ id: String,
    to value: Double?,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.lateFeeInCents = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Increment the lateFeeInCents field of a BorrowRecord.
  @MainActor
  public func incrementLateFeeInCents(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.lateFeeInCents += amount
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Decrement the lateFeeInCents field of a BorrowRecord.
  @MainActor
  public func decrementLateFeeInCents(
    _ id: String,
    by amount: Double = 1,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    incrementLateFeeInCents(id, by: -amount, callbacks: callbacks)
  }

  // MARK: Delete

  /// Delete a BorrowRecord by ID.
  @MainActor
  public func deleteBorrowRecord(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a BorrowRecord entity.
  @MainActor
  public func deleteBorrowRecord(
    _ entity: BorrowRecord,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteBorrowRecord(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Book

  /// Link a BorrowRecord to a Book via 'book'.
  @MainActor
  public func linkBook(
    _ id: String,
    to target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "book", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a BorrowRecord from a Book via 'book'.
  @MainActor
  public func unlinkBook(
    _ id: String,
    from target: Book,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "book", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Link/Unlink Member

  /// Link a BorrowRecord to a Member via 'member'.
  @MainActor
  public func linkMember(
    _ id: String,
    to target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "member", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a BorrowRecord from a Member via 'member'.
  @MainActor
  public func unlinkMember(
    _ id: String,
    from target: Member,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "member", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == BorrowRecord {

  // MARK: Create

  /// Create a new BorrowRecord and sync to InstantDB.
  @MainActor
  public func createBorrowRecord(
    id: String = UUID().uuidString.lowercased(),
    borrowedAt: Date,
    dueAt: Date,
    returnedAt: Date? = nil,
    lateFeeInCents: Double? = nil,
    callbacks: MutationCallbacks<BorrowRecord> = .init()
  ) {
    callbacks.onMutate?()
    let entity = BorrowRecord(
      id: id,
      borrowedAt: borrowedAt,
      dueAt: dueAt,
      returnedAt: returnedAt,
      lateFeeInCents: lateFeeInCents
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a BorrowRecord by ID.
  @MainActor
  public func deleteBorrowRecord(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a BorrowRecord entity.
  @MainActor
  public func deleteBorrowRecord(
    _ entity: BorrowRecord,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteBorrowRecord(entity.id, callbacks: callbacks)
  }
}

