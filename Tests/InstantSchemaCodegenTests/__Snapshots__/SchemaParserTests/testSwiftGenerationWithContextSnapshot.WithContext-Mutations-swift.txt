/// ═══════════════════════════════════════════════════════════════════════════════
/// Mutations.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains type-safe mutation extensions for each entity in your
/// InstantDB schema. These methods provide explicit operations (create, update,
/// delete, link, unlink) with TanStack Query-style callbacks.
/// Benefits over withLock mutations:
/// • Explicit operations - no diff computation
/// • Type-safe field updates - compiler catches typos
/// • Semantic methods - toggleDone(), incrementLikes()
/// • Callbacks for success/error handling
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Use the generated mutation methods on your @Shared collections:
///   @Shared(Schema.todos)
///   private var items: IdentifiedArrayOf<Todo> = []
///   // Create with all fields
///   $items.createTodo(title: value)
///   // Update specific field
///   $items.updateTitle(itemId, to: newValue)
///   // Delete by ID or entity
///   $items.deleteTodo(itemId)
///   $items.deleteTodo(item)
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct TodoMutationsView: View {
  @Shared(Schema.todos)
  private var items: IdentifiedArrayOf<Todo> = []

  var body: some View {
    List(items) { item in
      Text("\(item.id)")
    }
  }

  private func createItem() {
    $items.createTodo(
      title: "value",
      callbacks: MutationCallbacks(
        onSuccess: { item in print("Created: \(item.id)") },
        onError: { error in print("Error: \(error)") }
      )
    )
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Todo Mutations {
///   createTodo(...)
///   updateTitle(_:to:)
///   updateDone(_:to:)
///   toggleDone(_:)
///   markDone(_:)
///   unmarkDone(_:)
///   updatePriority(_:to:)
///   deleteTodo(_:) // by ID
///   deleteTodo(_:) // by entity
///   linkOwner(_:to:)
///   unlinkOwner(_:from:)
/// }
///
/// User Mutations {
///   createUser(...)
///   updateName(_:to:)
///   updateEmail(_:to:)
///   updateCreatedAt(_:to:)
///   deleteUser(_:) // by ID
///   deleteUser(_:) // by entity
///   linkTodos(_:to:)
///   unlinkTodos(_:from:)
/// }
///

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// GENERATION INFO
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Mode:            Production (full traceability)
/// Generated:       December 18, 2024 at 7:24 PM EST
/// Machine:         test-machine (Apple M1, macOS 14.0)
/// Generator:       Sources/instant-schema/main.swift
/// Source Schema:   Tests/Fixtures/SimpleSchema.ts

/* To regenerate this file, run:

swift run instant-schema generate \
  --from test.schema.ts \
  --to Sources/Generated/
*/
/// ─────────────────────────────────────────────────────────────────────────────────
/// GIT STATE AT GENERATION
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// HEAD Commit:
///   SHA:      abc123def456789012345678901234567890abcd
///   Date:     December 18, 2024 at 7:23 PM EST
///   Author:   Test Author <test@example.com>
///   Message:  test: Add test commit for snapshot testing
///
/// Schema File Last Modified:
///   SHA:      def456abc789012345678901234567890abcdef
///   Date:     December 18, 2024 at 7:21 PM EST
///   Author:   Schema Author <schema@example.com>
///   Message:  feat: Update schema with new entities
///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import IdentifiedCollections
import Sharing
import SharingInstant

// MARK: - Todo Mutations

public extension Shared where Value == IdentifiedArrayOf<Todo> {

  // MARK: Create

  /// Create a new Todo and sync to InstantDB.
  @MainActor
   func createTodo(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    done: Bool,
    priority: Double? = nil,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Todo(
      id: id,
      title: title,
      done: done,
      priority: priority
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the title field of a Todo.
  @MainActor
   func updateTitle(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.title = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the done field of a Todo.
  @MainActor
   func updateDone(
    _ id: String,
    to value: Bool,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.done = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Toggle the done field of a Todo.
  @MainActor
   func toggleDone(
    _ id: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.done.toggle()
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Set done to true for a Todo.
  @MainActor
   func markDone(
    _ id: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    updateDone(id, to: true, callbacks: callbacks)
  }

  /// Set done to false for a Todo.
  @MainActor
   func unmarkDone(
    _ id: String,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    updateDone(id, to: false, callbacks: callbacks)
  }

  /// Update the priority field of a Todo.
  @MainActor
   func updatePriority(
    _ id: String,
    to value: Double?,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.priority = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Todo by ID.
  @MainActor
   func deleteTodo(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Todo entity.
  @MainActor
   func deleteTodo(
    _ entity: Todo,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTodo(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Owner

  /// Link a Todo to a User via 'owner'.
  @MainActor
   func linkOwner(
    _ id: String,
    to target: User,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "owner", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a Todo from a User via 'owner'.
  @MainActor
   func unlinkOwner(
    _ id: String,
    from target: User,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "owner", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == Todo {

  // MARK: Create

  /// Create a new Todo and sync to InstantDB.
  @MainActor
   func createTodo(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    done: Bool,
    priority: Double? = nil,
    callbacks: MutationCallbacks<Todo> = .init()
  ) {
    callbacks.onMutate?()
    let entity = Todo(
      id: id,
      title: title,
      done: done,
      priority: priority
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a Todo by ID.
  @MainActor
   func deleteTodo(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a Todo entity.
  @MainActor
   func deleteTodo(
    _ entity: Todo,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteTodo(entity.id, callbacks: callbacks)
  }
}

// MARK: - User Mutations

public extension Shared where Value == IdentifiedArrayOf<User> {

  // MARK: Create

  /// Create a new User and sync to InstantDB.
  @MainActor
   func createUser(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    email: String,
    createdAt: Date,
    callbacks: MutationCallbacks<User> = .init()
  ) {
    callbacks.onMutate?()
    let entity = User(
      id: id,
      name: name,
      email: email,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the name field of a User.
  @MainActor
   func updateName(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<User> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.name = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the email field of a User.
  @MainActor
   func updateEmail(
    _ id: String,
    to value: String,
    callbacks: MutationCallbacks<User> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.email = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Update the createdAt field of a User.
  @MainActor
   func updateCreatedAt(
    _ id: String,
    to value: Date,
    callbacks: MutationCallbacks<User> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.update(id: id) { entity in
          entity.createdAt = value
        }
        if let updated = self.wrappedValue[id: id] {
          callbacks.onSuccess?(updated)
        }
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a User by ID.
  @MainActor
   func deleteUser(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a User entity.
  @MainActor
   func deleteUser(
    _ entity: User,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteUser(entity.id, callbacks: callbacks)
  }

  // MARK: Link/Unlink Todos

  /// Link a User to a Todo via 'todos'.
  @MainActor
   func linkTodos(
    _ id: String,
    to target: Todo,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.link(id, "todos", to: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Unlink a User from a Todo via 'todos'.
  @MainActor
   func unlinkTodos(
    _ id: String,
    from target: Todo,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.unlink(id, "todos", from: target)
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }
}

public extension Shared where Value: RangeReplaceableCollection, Value.Element == User {

  // MARK: Create

  /// Create a new User and sync to InstantDB.
  @MainActor
   func createUser(
    id: String = UUID().uuidString.lowercased(),
    name: String,
    email: String,
    createdAt: Date,
    callbacks: MutationCallbacks<User> = .init()
  ) {
    callbacks.onMutate?()
    let entity = User(
      id: id,
      name: name,
      email: email,
      createdAt: createdAt
    )
    Task {
      do {
        try await self.create(entity)
        callbacks.onSuccess?(entity)
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  // MARK: Delete

  /// Delete a User by ID.
  @MainActor
   func deleteUser(
    _ id: String,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    callbacks.onMutate?()
    Task {
      do {
        try await self.delete(id: id) as Void
        callbacks.onSuccess?(())
      } catch {
        callbacks.onError?(error)
      }
      callbacks.onSettled?()
    }
  }

  /// Delete a User entity.
  @MainActor
   func deleteUser(
    _ entity: User,
    callbacks: MutationCallbacks<Void> = .init()
  ) {
    deleteUser(entity.id, callbacks: callbacks)
  }
}

