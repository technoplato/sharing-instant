// Links.swift
// Generated by InstantSchemaCodegen
// 2025-12-18T07:35:59Z
//
// DO NOT EDIT - This file is generated from your InstantDB schema.
// Any changes will be overwritten on the next codegen run.

import Foundation
import SharingInstant

// MARK: - Link Definitions

/// Metadata about all links in the schema.
///
/// These are used for advanced link operations and query building.
public enum SchemaLinks {
  /// speakers ↔ people relationship
  /// Link speakers to their person (People entity).
A speaker is a person in a specific speaking role.
  public static let speakersPerson = Link(
    name: "speakersPerson",
    from: Speaker.self, fromLabel: "person", fromCardinality: .one,
    to: Person.self, toLabel: "speakers", toCardinality: .many
  )

  /// externalPeopleIds ↔ people relationship
  /// Link external people IDs to their person.
  public static let externalPeopleIdsPerson = Link(
    name: "externalPeopleIdsPerson",
    from: ExternalPeopleId.self, fromLabel: "person", fromCardinality: .one,
    to: Person.self, toLabel: "externalIds", toCardinality: .many
  )

  /// externalPeopleIds ↔ platforms relationship
  /// Link external people IDs to their platform.
  public static let externalPeopleIdsPlatform = Link(
    name: "externalPeopleIdsPlatform",
    from: ExternalPeopleId.self, fromLabel: "platform", fromCardinality: .one,
    to: Platform.self, toLabel: "externalPeopleIds", toCardinality: .many
  )

  /// mediaFiles ↔ media relationship
  /// Link media files to their media.
  public static let mediaFilesMedia = Link(
    name: "mediaFilesMedia",
    from: MediaFile.self, fromLabel: "media", fromCardinality: .one,
    to: Media.self, toLabel: "files", toCardinality: .many
  )

  /// segments ↔ media relationship
  /// Link segments to their media.
  public static let segmentsMedia = Link(
    name: "segmentsMedia",
    from: Segment.self, fromLabel: "media", fromCardinality: .one,
    to: Media.self, toLabel: "segments", toCardinality: .many
  )

  /// segments ↔ segments relationship
  /// Link segments to their parent segment (for sub-chapters/nested sections).
  public static let segmentsParent = Link(
    name: "segmentsParent",
    from: Segment.self, fromLabel: "parent", fromCardinality: .one,
    to: Segment.self, toLabel: "children", toCardinality: .many
  )

  /// externalMediaIds ↔ media relationship
  /// Link external media IDs to their media.
  public static let externalMediaIdsMedia = Link(
    name: "externalMediaIdsMedia",
    from: ExternalMediaId.self, fromLabel: "media", fromCardinality: .one,
    to: Media.self, toLabel: "externalIds", toCardinality: .many
  )

  /// externalMediaIds ↔ platforms relationship
  /// Link external media IDs to their platform.
  public static let externalMediaIdsPlatform = Link(
    name: "externalMediaIdsPlatform",
    from: ExternalMediaId.self, fromLabel: "platform", fromCardinality: .one,
    to: Platform.self, toLabel: "externalMediaIds", toCardinality: .many
  )

  /// externalSegmentIds ↔ segments relationship
  /// Link external segment IDs to their segment.
  public static let externalSegmentIdsSegment = Link(
    name: "externalSegmentIdsSegment",
    from: ExternalSegmentId.self, fromLabel: "segment", fromCardinality: .one,
    to: Segment.self, toLabel: "externalIds", toCardinality: .many
  )

  /// externalSegmentIds ↔ platforms relationship
  /// Link external segment IDs to their platform.
  public static let externalSegmentIdsPlatform = Link(
    name: "externalSegmentIdsPlatform",
    from: ExternalSegmentId.self, fromLabel: "platform", fromCardinality: .one,
    to: Platform.self, toLabel: "externalSegmentIds", toCardinality: .many
  )

  /// accessMetadata ↔ externalMediaIds relationship
  /// Link access metadata to its external media ID.
  public static let accessMetadataExternalMediaId = Link(
    name: "accessMetadataExternalMediaId",
    from: AccessMetadata.self, fromLabel: "externalMediaId", fromCardinality: .one,
    to: ExternalMediaId.self, toLabel: "accessMetadata", toCardinality: .one
  )

  /// media ↔ speakers relationship
  /// Link media to its author (Speaker entity).
  public static let mediaAuthor = Link(
    name: "mediaAuthor",
    from: Media.self, fromLabel: "author", fromCardinality: .one,
    to: Speaker.self, toLabel: "authoredMedia", toCardinality: .many
  )

  /// media ↔ speakers relationship
  /// Link media to its narrator (Speaker entity, for audiobooks).
  public static let mediaNarrator = Link(
    name: "mediaNarrator",
    from: Media.self, fromLabel: "narrator", fromCardinality: .one,
    to: Speaker.self, toLabel: "narratedMedia", toCardinality: .many
  )

  /// shazamCatalogEntries ↔ media relationship
  /// Link shazam catalog entries to media (new entity).
  public static let shazamCatalogEntriesMedia = Link(
    name: "shazamCatalogEntriesMedia",
    from: ShazamCatalogEntry.self, fromLabel: "media", fromCardinality: .one,
    to: Media.self, toLabel: "shazamCatalogEntries", toCardinality: .many
  )

  /// media ↔ diarizationRuns relationship
  /// Link diarization runs to media (new entity).
  public static let mediaDiarizationRuns = Link(
    name: "mediaDiarizationRuns",
    from: Media.self, fromLabel: "diarizationRuns", fromCardinality: .many,
    to: DiarizationRun.self, toLabel: "media", toCardinality: .one
  )

  /// media ↔ transcriptionRuns relationship
  /// Link transcription runs to media (new entity).
  public static let mediaTranscriptionRuns = Link(
    name: "mediaTranscriptionRuns",
    from: Media.self, fromLabel: "transcriptionRuns", fromCardinality: .many,
    to: TranscriptionRun.self, toLabel: "media", toCardinality: .one
  )

  /// $users ↔ $users relationship
  public static let $usersLinkedPrimaryUser = Link(
    name: "$usersLinkedPrimaryUser",
    from: $user.self, fromLabel: "linkedPrimaryUser", fromCardinality: .one,
    to: $user.self, toLabel: "linkedGuestUsers", toCardinality: .many
  )

  /// diarizationRuns ↔ diarizationConfigs relationship
  public static let diarizationRunsConfig = Link(
    name: "diarizationRunsConfig",
    from: DiarizationRun.self, fromLabel: "config", fromCardinality: .one,
    to: DiarizationConfig.self, toLabel: "diarizationRuns", toCardinality: .many
  )

  /// diarizationRuns ↔ diarizationSegments relationship
  public static let diarizationRunsDiarizationSegments = Link(
    name: "diarizationRunsDiarizationSegments",
    from: DiarizationRun.self, fromLabel: "diarizationSegments", fromCardinality: .many,
    to: DiarizationSegment.self, toLabel: "diarizationRun", toCardinality: .one
  )

  /// diarizationSegments ↔ speakerAssignments relationship
  public static let diarizationSegmentsSpeakerAssignments = Link(
    name: "diarizationSegmentsSpeakerAssignments",
    from: DiarizationSegment.self, fromLabel: "speakerAssignments", fromCardinality: .many,
    to: SpeakerAssignment.self, toLabel: "diarizationSegment", toCardinality: .one
  )

  /// segmentSplits ↔ diarizationSegments relationship
  public static let segmentSplitsOriginalSegment = Link(
    name: "segmentSplitsOriginalSegment",
    from: SegmentSplit.self, fromLabel: "originalSegment", fromCardinality: .one,
    to: DiarizationSegment.self, toLabel: "splits", toCardinality: .many
  )

  /// segmentSplits ↔ diarizationSegments relationship
  public static let segmentSplitsResultingSegments = Link(
    name: "segmentSplitsResultingSegments",
    from: SegmentSplit.self, fromLabel: "resultingSegments", fromCardinality: .many,
    to: DiarizationSegment.self, toLabel: "createdFromSplit", toCardinality: .one
  )

  /// shazamCatalogEntries ↔ videos relationship
  public static let shazamCatalogEntriesVideo = Link(
    name: "shazamCatalogEntriesVideo",
    from: ShazamCatalogEntry.self, fromLabel: "video", fromCardinality: .one,
    to: Video.self, toLabel: "shazamCatalogEntries", toCardinality: .many
  )

  /// speakerAssignments ↔ speakers relationship
  public static let speakerAssignmentsSpeaker = Link(
    name: "speakerAssignmentsSpeaker",
    from: SpeakerAssignment.self, fromLabel: "speaker", fromCardinality: .one,
    to: Speaker.self, toLabel: "speakerAssignments", toCardinality: .many
  )

  /// speakers ↔ publications relationship
  public static let speakersPublications = Link(
    name: "speakersPublications",
    from: Speaker.self, fromLabel: "publications", fromCardinality: .many,
    to: Publication.self, toLabel: "regularSpeakers", toCardinality: .many
  )

  /// transcriptionRuns ↔ transcriptionConfigs relationship
  public static let transcriptionRunsConfig = Link(
    name: "transcriptionRunsConfig",
    from: TranscriptionRun.self, fromLabel: "config", fromCardinality: .one,
    to: TranscriptionConfig.self, toLabel: "transcriptionRuns", toCardinality: .many
  )

  /// transcriptionRuns ↔ words relationship
  public static let transcriptionRunsWords = Link(
    name: "transcriptionRunsWords",
    from: TranscriptionRun.self, fromLabel: "words", fromCardinality: .many,
    to: Word.self, toLabel: "transcriptionRun", toCardinality: .one
  )

  /// videos ↔ diarizationRuns relationship
  public static let videosDiarizationRuns = Link(
    name: "videosDiarizationRuns",
    from: Video.self, fromLabel: "diarizationRuns", fromCardinality: .many,
    to: DiarizationRun.self, toLabel: "video", toCardinality: .one
  )

  /// videos ↔ publications relationship
  public static let videosPublication = Link(
    name: "videosPublication",
    from: Video.self, fromLabel: "publication", fromCardinality: .one,
    to: Publication.self, toLabel: "videos", toCardinality: .many
  )

  /// videos ↔ shazamMatches relationship
  public static let videosShazamMatches = Link(
    name: "videosShazamMatches",
    from: Video.self, fromLabel: "shazamMatches", fromCardinality: .many,
    to: ShazamMatch.self, toLabel: "video", toCardinality: .one
  )

  /// videos ↔ transcriptionRuns relationship
  public static let videosTranscriptionRuns = Link(
    name: "videosTranscriptionRuns",
    from: Video.self, fromLabel: "transcriptionRuns", fromCardinality: .many,
    to: TranscriptionRun.self, toLabel: "video", toCardinality: .one
  )

  /// words ↔ wordTextCorrections relationship
  public static let wordsTextCorrections = Link(
    name: "wordsTextCorrections",
    from: Word.self, fromLabel: "textCorrections", fromCardinality: .many,
    to: WordTextCorrection.self, toLabel: "word", toCardinality: .one
  )

  /// audiobooks ↔ speakers relationship
  /// Link audiobook to its narrator (speaker entity).
  public static let audiobooksNarrator = Link(
    name: "audiobooksNarrator",
    from: Audiobook.self, fromLabel: "narrator", fromCardinality: .one,
    to: Speaker.self, toLabel: "narratedAudiobooks", toCardinality: .many
  )

  /// audiobooks ↔ speakers relationship
  /// Link audiobook to its author (speaker entity, optional - author may also be narrator).
  public static let audiobooksAuthor = Link(
    name: "audiobooksAuthor",
    from: Audiobook.self, fromLabel: "author", fromCardinality: .one,
    to: Speaker.self, toLabel: "authoredAudiobooks", toCardinality: .many
  )

  /// audiobookChapters ↔ audiobooks relationship
  /// Link chapters to their audiobook.
  public static let audiobookChaptersAudiobook = Link(
    name: "audiobookChaptersAudiobook",
    from: AudiobookChapter.self, fromLabel: "audiobook", fromCardinality: .one,
    to: Audiobook.self, toLabel: "chapters", toCardinality: .many
  )

  /// audiobookChapters ↔ audiobookChapters relationship
  /// Link sub-chapters to their parent chapter.
  public static let audiobookChaptersParent = Link(
    name: "audiobookChaptersParent",
    from: AudiobookChapter.self, fromLabel: "parentChapter", fromCardinality: .one,
    to: AudiobookChapter.self, toLabel: "subchapters", toCardinality: .many
  )

  /// videos ↔ audiobooks relationship
  /// Link video (audio file) to its audiobook.
A video can be a chapter clip from an audiobook.
  public static let videosAudiobook = Link(
    name: "videosAudiobook",
    from: Video.self, fromLabel: "audiobook", fromCardinality: .one,
    to: Audiobook.self, toLabel: "audioFiles", toCardinality: .many
  )

  /// videos ↔ audiobookChapters relationship
  /// Link video (audio file) to its chapter.
Used when a video represents a specific chapter clip.
  public static let videosAudiobookChapter = Link(
    name: "videosAudiobookChapter",
    from: Video.self, fromLabel: "audiobookChapter", fromCardinality: .one,
    to: AudiobookChapter.self, toLabel: "audioFiles", toCardinality: .many
  )

}

// MARK: - Link Type

/// Represents a bidirectional link between two entities.
public struct Link<From: InstantEntity, To: InstantEntity>: Sendable {
  public let name: String
  public let fromLabel: String
  public let fromCardinality: LinkCardinality
  public let toLabel: String
  public let toCardinality: LinkCardinality
  
  public init(
    name: String,
    from: From.Type,
    fromLabel: String,
    fromCardinality: LinkCardinality,
    to: To.Type,
    toLabel: String,
    toCardinality: LinkCardinality
  ) {
    self.name = name
    self.fromLabel = fromLabel
    self.fromCardinality = fromCardinality
    self.toLabel = toLabel
    self.toCardinality = toCardinality
  }
}

/// The cardinality of one side of a link.
public enum LinkCardinality: String, Sendable {
  case one
  case many
}
