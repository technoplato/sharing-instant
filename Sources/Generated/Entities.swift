// Entities.swift
// Generated by InstantSchemaCodegen
// 2025-12-18T07:35:59Z
//
// DO NOT EDIT - This file is generated from your InstantDB schema.
// Any changes will be overwritten on the next codegen run.

import Foundation
import SharingInstant

public struct $file: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "$files" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var path: String
  public var url: String

  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    path: String,
    url: String
  ) {
    self.id = id
    self.path = path
    self.url = url
  }
}


public struct $user: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "$users" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var email: String
  public var imageURL: String?
  public var type: String?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to $users via '$usersLinkedPrimaryUser'
  /// - Note: Only populated when queried with `.with(\.linkedPrimaryUser)`
  public var linkedPrimaryUser: $user?

  /// Link to $users via '$usersLinkedPrimaryUser'
  /// - Note: Only populated when queried with `.with(\.linkedGuestUsers)`
  public var linkedGuestUsers: [$user]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    email: String,
    imageURL: String? = nil,
    type: String? = nil,
    linkedPrimaryUser: $user? = nil,
    linkedGuestUsers: [$user]? = nil
  ) {
    self.id = id
    self.email = email
    self.imageURL = imageURL
    self.type = type
    self.linkedPrimaryUser = linkedPrimaryUser
    self.linkedGuestUsers = linkedGuestUsers
  }
}


/// A person in the real world.
/// People exist independently of their roles. A person may be an author,
/// narrator, podcast host, guest making an appearance, article writer,
/// or just referenced/mentioned in media. Not all
public struct Person: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "people" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var name: String
  public var bio: String?
  public var ingested_at: String
  public var metadata: AnyCodable?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to speakers via 'speakersPerson'
  /// - Note: Only populated when queried with `.with(\.speakers)`
  public var speakers: [Speaker]?

  /// Link to externalPeopleIds via 'externalPeopleIdsPerson'
  /// - Note: Only populated when queried with `.with(\.externalIds)`
  public var externalIds: [ExternalPeopleId]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    name: String,
    bio: String? = nil,
    ingested_at: String,
    metadata: AnyCodable? = nil,
    speakers: [Speaker]? = nil,
    externalIds: [ExternalPeopleId]? = nil
  ) {
    self.id = id
    self.name = name
    self.bio = bio
    self.ingested_at = ingested_at
    self.metadata = metadata
    self.speakers = speakers
    self.externalIds = externalIds
  }
}


/// A piece of
public struct Media: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "media" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var media_type: String
  public var duration_seconds: Double
  public var description: String?
  public var ingested_at: String
  public var published_at: String?
  public var source_metadata: AnyCodable?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to speakers via 'mediaAuthor'
  /// - Note: Only populated when queried with `.with(\.author)`
  public var author: Speaker?

  /// Link to speakers via 'mediaNarrator'
  /// - Note: Only populated when queried with `.with(\.narrator)`
  public var narrator: Speaker?

  /// Link to diarizationRuns via 'mediaDiarizationRuns'
  /// - Note: Only populated when queried with `.with(\.diarizationRuns)`
  public var diarizationRuns: [DiarizationRun]?

  /// Link to transcriptionRuns via 'mediaTranscriptionRuns'
  /// - Note: Only populated when queried with `.with(\.transcriptionRuns)`
  public var transcriptionRuns: [TranscriptionRun]?

  /// Link to mediaFiles via 'mediaFilesMedia'
  /// - Note: Only populated when queried with `.with(\.files)`
  public var files: [MediaFile]?

  /// Link to segments via 'segmentsMedia'
  /// - Note: Only populated when queried with `.with(\.segments)`
  public var segments: [Segment]?

  /// Link to externalMediaIds via 'externalMediaIdsMedia'
  /// - Note: Only populated when queried with `.with(\.externalIds)`
  public var externalIds: [ExternalMediaId]?

  /// Link to shazamCatalogEntries via 'shazamCatalogEntriesMedia'
  /// - Note: Only populated when queried with `.with(\.shazamCatalogEntries)`
  public var shazamCatalogEntries: [ShazamCatalogEntry]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    title: String,
    media_type: String,
    duration_seconds: Double,
    description: String? = nil,
    ingested_at: String,
    published_at: String? = nil,
    source_metadata: AnyCodable? = nil,
    author: Speaker? = nil,
    narrator: Speaker? = nil,
    diarizationRuns: [DiarizationRun]? = nil,
    transcriptionRuns: [TranscriptionRun]? = nil,
    files: [MediaFile]? = nil,
    segments: [Segment]? = nil,
    externalIds: [ExternalMediaId]? = nil,
    shazamCatalogEntries: [ShazamCatalogEntry]? = nil
  ) {
    self.id = id
    self.title = title
    self.media_type = media_type
    self.duration_seconds = duration_seconds
    self.description = description
    self.ingested_at = ingested_at
    self.published_at = published_at
    self.source_metadata = source_metadata
    self.author = author
    self.narrator = narrator
    self.diarizationRuns = diarizationRuns
    self.transcriptionRuns = transcriptionRuns
    self.files = files
    self.segments = segments
    self.externalIds = externalIds
    self.shazamCatalogEntries = shazamCatalogEntries
  }
}


/// A file storing media content, either locally or remotely.
/// Supports distributed caching: the same media may have files on multiple
/// machines. Query by machine_id to find files available locally.
/// Machine identification: Use IOPlatformUUID on macOS (stable, unique per machine).
/// Get it via: ioreg -rd1 -c IOPlatformExpertDevice | grep IOPlatformUUID
/// Example: "CF17FBE0-0E64-5426-8FC8-00DB233891F4"
/// Examples:
/// - Local MP3: machine_id="CF17FBE0-...", path="/Users/me/audiobooks/new-earth.mp3"
/// - Server copy: machine_id="ABC123...", path="/srv/audiobooks/new-earth.mp3"
/// - Remote URL: machine_id=null, remote_url="https:cdn.example.com/new-earth.mp3"
/// Links:
/// - media: The Media entity this file belongs to
public struct MediaFile: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "mediaFiles" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var path: String
  public var remote_url: String?
  public var machine_id: String
  public var format: String
  public var mime_type: String?
  public var size_bytes: Double?
  public var access_requirements: AnyCodable?
  public var ingested_at: String
  public var last_accessed_at: String?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to media via 'mediaFilesMedia'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: Media?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    path: String,
    remote_url: String? = nil,
    machine_id: String,
    format: String,
    mime_type: String? = nil,
    size_bytes: Double? = nil,
    access_requirements: AnyCodable? = nil,
    ingested_at: String,
    last_accessed_at: String? = nil,
    media: Media? = nil
  ) {
    self.id = id
    self.path = path
    self.remote_url = remote_url
    self.machine_id = machine_id
    self.format = format
    self.mime_type = mime_type
    self.size_bytes = size_bytes
    self.access_requirements = access_requirements
    self.ingested_at = ingested_at
    self.last_accessed_at = last_accessed_at
    self.media = media
  }
}


/// A named time range within media.
/// Platform-agnostic: represents chapters, sections, tracks, or any named
/// portion of media. Can be nested (parent/child) for sub-chapters.
/// Source types (how the segment was created):
/// - "import": Imported from external metadata
/// - "manual": Manually annotated by a user
/// - "auto": Auto-detected (silence detection, topic change, etc.)
/// - "script": Created by an ingestion script
/// Source (where the data came from, when source_type is "import" or "script"):
/// - "audible_json": Audible chapter JSON file
/// - "youtube_api": YouTube Data API chapters
/// - "audio_ingestion.py": Our audio ingestion script
/// - etc.
/// Examples:
/// - Audiobook chapter: "Chapter One: The Ego" (parent)
/// - Audiobook sub-chapter: "Evocation" (child of above)
/// - Podcast segment: "Interview", "Ad Break"
/// Links:
/// - media: The Media this segment belongs to
/// - parent: Parent segment (for sub-chapters/nested sections)
/// - children: Child
public struct Segment: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "segments" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var start_time_ms: Double
  public var end_time_ms: Double
  public var length_ms: Double
  public var ordinal: Double
  public var source_type: String
  public var source: String
  public var source_metadata: AnyCodable?
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to media via 'segmentsMedia'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: Media?

  /// Link to segments via 'segmentsParent'
  /// - Note: Only populated when queried with `.with(\.parent)`
  public var parent: Segment?

  /// Link to segments via 'segmentsParent'
  /// - Note: Only populated when queried with `.with(\.children)`
  public var children: [Segment]?

  /// Link to externalSegmentIds via 'externalSegmentIdsSegment'
  /// - Note: Only populated when queried with `.with(\.externalIds)`
  public var externalIds: [ExternalSegmentId]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    title: String,
    start_time_ms: Double,
    end_time_ms: Double,
    length_ms: Double,
    ordinal: Double,
    source_type: String,
    source: String,
    source_metadata: AnyCodable? = nil,
    ingested_at: String,
    media: Media? = nil,
    parent: Segment? = nil,
    children: [Segment]? = nil,
    externalIds: [ExternalSegmentId]? = nil
  ) {
    self.id = id
    self.title = title
    self.start_time_ms = start_time_ms
    self.end_time_ms = end_time_ms
    self.length_ms = length_ms
    self.ordinal = ordinal
    self.source_type = source_type
    self.source = source
    self.source_metadata = source_metadata
    self.ingested_at = ingested_at
    self.media = media
    self.parent = parent
    self.children = children
    self.externalIds = externalIds
  }
}


/// An external platform where media or people can be found.
/// Examples:
/// - YouTube (video, text posts)
/// - Audible (audiobooks)
/// - Spotify (podcasts, music)
/// - Twitter/X (profiles, posts, videos)
/// - Medium (articles)
/// - dev.to (articles)
/// - Wikipedia (reference)
/// - Wikidata (structured data)
/// - Libby (library audiobooks/ebooks)
/// Links:
/// - externalMediaIds: Media linked to this platform
/// - externalPeopleIds: People linked to this platform
/// - externalSegmentIds: Segments linked to this platform
public struct Platform: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "platforms" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var name: String
  public var base_url: String?
  public var content_types: AnyCodable?
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to externalPeopleIds via 'externalPeopleIdsPlatform'
  /// - Note: Only populated when queried with `.with(\.externalPeopleIds)`
  public var externalPeopleIds: [ExternalPeopleId]?

  /// Link to externalMediaIds via 'externalMediaIdsPlatform'
  /// - Note: Only populated when queried with `.with(\.externalMediaIds)`
  public var externalMediaIds: [ExternalMediaId]?

  /// Link to externalSegmentIds via 'externalSegmentIdsPlatform'
  /// - Note: Only populated when queried with `.with(\.externalSegmentIds)`
  public var externalSegmentIds: [ExternalSegmentId]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    name: String,
    base_url: String? = nil,
    content_types: AnyCodable? = nil,
    ingested_at: String,
    externalPeopleIds: [ExternalPeopleId]? = nil,
    externalMediaIds: [ExternalMediaId]? = nil,
    externalSegmentIds: [ExternalSegmentId]? = nil
  ) {
    self.id = id
    self.name = name
    self.base_url = base_url
    self.content_types = content_types
    self.ingested_at = ingested_at
    self.externalPeopleIds = externalPeopleIds
    self.externalMediaIds = externalMediaIds
    self.externalSegmentIds = externalSegmentIds
  }
}


/// Links media to an external platform with platform-specific identifiers.
/// Examples:
/// - Audible: platform="Audible", external_id="B002V0RAUU",
/// normalized_url="https:www.audible.com/pd/B002V0RAUU"
/// - YouTube: platform="YouTube", external_id="jNQXAC9IVRw",
/// normalized_url="https:www.youtube.com/watch?v=jNQXAC9IVRw"
/// (Note: YouTube has many URL formats - use yt-dlp's URL normalization)
/// Links:
/// - media: The Media entity this refers to
/// - platform: The Platform this ID is on
/// - accessMetadata: Access restrictions (paywall, subscription, etc.)
public struct ExternalMediaId: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "externalMediaIds" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var external_id: String
  public var normalized_url: String
  public var external_published_at: String?
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to media via 'externalMediaIdsMedia'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: Media?

  /// Link to platforms via 'externalMediaIdsPlatform'
  /// - Note: Only populated when queried with `.with(\.platform)`
  public var platform: Platform?

  /// Link to accessMetadata via 'accessMetadataExternalMediaId'
  /// - Note: Only populated when queried with `.with(\.accessMetadata)`
  public var accessMetadata: AccessMetadata?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    external_id: String,
    normalized_url: String,
    external_published_at: String? = nil,
    ingested_at: String,
    media: Media? = nil,
    platform: Platform? = nil,
    accessMetadata: AccessMetadata? = nil
  ) {
    self.id = id
    self.external_id = external_id
    self.normalized_url = normalized_url
    self.external_published_at = external_published_at
    self.ingested_at = ingested_at
    self.media = media
    self.platform = platform
    self.accessMetadata = accessMetadata
  }
}


/// Links people to their profiles on external platforms.
/// Examples:
/// - YouTube channel: platform="YouTube", external_id="UCxxxxxx",
/// normalized_url="https:www.youtube.com/@lexfridman"
/// - Twitter: platform="Twitter", external_id="lexfridman",
/// normalized_url="https:twitter.com/lexfridman"
/// - Wikidata: platform="Wikidata", external_id="Q123456",
/// normalized_url="https:www.wikidata.org/wiki/Q123456"
/// - Wikipedia: platform="Wikipedia", external_id="Eckhart_Tolle",
/// normalized_url="https:en.wikipedia.org/wiki/Eckhart_Tolle"
/// Links:
/// - person: The People entity this refers to
/// - platform: The Platform this profile is on
public struct ExternalPeopleId: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "externalPeopleIds" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var external_id: String
  public var normalized_url: String
  public var external_created_at: String?
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to people via 'externalPeopleIdsPerson'
  /// - Note: Only populated when queried with `.with(\.person)`
  public var person: Person?

  /// Link to platforms via 'externalPeopleIdsPlatform'
  /// - Note: Only populated when queried with `.with(\.platform)`
  public var platform: Platform?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    external_id: String,
    normalized_url: String,
    external_created_at: String? = nil,
    ingested_at: String,
    person: Person? = nil,
    platform: Platform? = nil
  ) {
    self.id = id
    self.external_id = external_id
    self.normalized_url = normalized_url
    self.external_created_at = external_created_at
    self.ingested_at = ingested_at
    self.person = person
    self.platform = platform
  }
}


/// Links segments to platform-specific deep links.
/// Examples:
/// - YouTube timestamp: normalized_url="https:www.youtube.com/watch?v=jNQXAC9IVRw&t=120"
/// - Spotify chapter: normalized_url="spotify:episode:xxx#t=120"
/// Links:
/// - segment: The Segment entity this refers to
/// - platform: The Platform this link is on
public struct ExternalSegmentId: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "externalSegmentIds" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var external_id: String
  public var normalized_url: String
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to segments via 'externalSegmentIdsSegment'
  /// - Note: Only populated when queried with `.with(\.segment)`
  public var segment: Segment?

  /// Link to platforms via 'externalSegmentIdsPlatform'
  /// - Note: Only populated when queried with `.with(\.platform)`
  public var platform: Platform?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    external_id: String,
    normalized_url: String,
    ingested_at: String,
    segment: Segment? = nil,
    platform: Platform? = nil
  ) {
    self.id = id
    self.external_id = external_id
    self.normalized_url = normalized_url
    self.ingested_at = ingested_at
    self.segment = segment
    self.platform = platform
  }
}


/// Describes access restrictions for external media.
/// Linked to ExternalMediaIds because access varies by platform:
/// - Same audiobook might be subscription on Audible, one-time on Apple Books,
/// or free via Libby (library)
/// - Same video might be free on YouTube, paywalled on Nebula
/// Access types (what gets in your way before you can access content):
/// - "free": No payment required, no account needed
/// - "free_with_ads": Free but has advertisements
/// - "account_required": Must create account (no additional payment)
/// - "subscription": Requires ongoing subscription (e.g., Audible, Netflix)
/// - "one_time_purchase": Single payment to own
/// - "rental": Temporary access for a fee
/// Links:
/// - externalMediaId: The external media link this describes
public struct AccessMetadata: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "accessMetadata" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var access_type: String
  public var has_ads: Bool?
  public var price_cents: Double?
  public var currency: String?
  public var last_checked_at: String?
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to externalMediaIds via 'accessMetadataExternalMediaId'
  /// - Note: Only populated when queried with `.with(\.externalMediaId)`
  public var externalMediaId: ExternalMediaId?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    access_type: String,
    has_ads: Bool? = nil,
    price_cents: Double? = nil,
    currency: String? = nil,
    last_checked_at: String? = nil,
    ingested_at: String,
    externalMediaId: ExternalMediaId? = nil
  ) {
    self.id = id
    self.access_type = access_type
    self.has_ads = has_ads
    self.price_cents = price_cents
    self.currency = currency
    self.last_checked_at = last_checked_at
    self.ingested_at = ingested_at
    self.externalMediaId = externalMediaId
  }
}


public struct DiarizationConfig: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "diarizationConfigs" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var additional_params: AnyCodable?
  public var cluster_threshold: Double?
  public var clustering_method: String?
  public var created_at: String
  public var embedding_model: String
  public var identification_threshold: Double?
  public var tool: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to diarizationRuns via 'diarizationRunsConfig'
  /// - Note: Only populated when queried with `.with(\.diarizationRuns)`
  public var diarizationRuns: [DiarizationRun]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    additional_params: AnyCodable? = nil,
    cluster_threshold: Double? = nil,
    clustering_method: String? = nil,
    created_at: String,
    embedding_model: String,
    identification_threshold: Double? = nil,
    tool: String,
    diarizationRuns: [DiarizationRun]? = nil
  ) {
    self.id = id
    self.additional_params = additional_params
    self.cluster_threshold = cluster_threshold
    self.clustering_method = clustering_method
    self.created_at = created_at
    self.embedding_model = embedding_model
    self.identification_threshold = identification_threshold
    self.tool = tool
    self.diarizationRuns = diarizationRuns
  }
}


public struct DiarizationRun: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "diarizationRuns" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var cost_usd: Double?
  public var executed_at: String
  public var git_commit_sha: String?
  public var input_duration_seconds: Double?
  public var is_preferred: Bool
  public var logs: AnyCodable?
  public var num_speakers_detected: Double?
  public var peak_memory_mb: Double?
  public var pipeline_script: String?
  public var processing_time_seconds: Double?
  public var tool_version: String?
  public var workflow: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to diarizationConfigs via 'diarizationRunsConfig'
  /// - Note: Only populated when queried with `.with(\.config)`
  public var config: DiarizationConfig?

  /// Link to diarizationSegments via 'diarizationRunsDiarizationSegments'
  /// - Note: Only populated when queried with `.with(\.diarizationSegments)`
  public var diarizationSegments: [DiarizationSegment]?

  /// Link to media via 'mediaDiarizationRuns'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: Media?

  /// Link to videos via 'videosDiarizationRuns'
  /// - Note: Only populated when queried with `.with(\.video)`
  public var video: Video?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    cost_usd: Double? = nil,
    executed_at: String,
    git_commit_sha: String? = nil,
    input_duration_seconds: Double? = nil,
    is_preferred: Bool,
    logs: AnyCodable? = nil,
    num_speakers_detected: Double? = nil,
    peak_memory_mb: Double? = nil,
    pipeline_script: String? = nil,
    processing_time_seconds: Double? = nil,
    tool_version: String? = nil,
    workflow: String,
    config: DiarizationConfig? = nil,
    diarizationSegments: [DiarizationSegment]? = nil,
    media: Media? = nil,
    video: Video? = nil
  ) {
    self.id = id
    self.cost_usd = cost_usd
    self.executed_at = executed_at
    self.git_commit_sha = git_commit_sha
    self.input_duration_seconds = input_duration_seconds
    self.is_preferred = is_preferred
    self.logs = logs
    self.num_speakers_detected = num_speakers_detected
    self.peak_memory_mb = peak_memory_mb
    self.pipeline_script = pipeline_script
    self.processing_time_seconds = processing_time_seconds
    self.tool_version = tool_version
    self.workflow = workflow
    self.config = config
    self.diarizationSegments = diarizationSegments
    self.media = media
    self.video = video
  }
}


public struct DiarizationSegment: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "diarizationSegments" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var confidence: Double?
  public var created_at: String
  public var embedding_id: String?
  public var end_time: Double
  public var is_invalidated: Bool?
  public var speaker_label: String
  public var start_time: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to speakerAssignments via 'diarizationSegmentsSpeakerAssignments'
  /// - Note: Only populated when queried with `.with(\.speakerAssignments)`
  public var speakerAssignments: [SpeakerAssignment]?

  /// Link to diarizationRuns via 'diarizationRunsDiarizationSegments'
  /// - Note: Only populated when queried with `.with(\.diarizationRun)`
  public var diarizationRun: DiarizationRun?

  /// Link to segmentSplits via 'segmentSplitsOriginalSegment'
  /// - Note: Only populated when queried with `.with(\.splits)`
  public var splits: [SegmentSplit]?

  /// Link to segmentSplits via 'segmentSplitsResultingSegments'
  /// - Note: Only populated when queried with `.with(\.createdFromSplit)`
  public var createdFromSplit: SegmentSplit?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    confidence: Double? = nil,
    created_at: String,
    embedding_id: String? = nil,
    end_time: Double,
    is_invalidated: Bool? = nil,
    speaker_label: String,
    start_time: Double,
    speakerAssignments: [SpeakerAssignment]? = nil,
    diarizationRun: DiarizationRun? = nil,
    splits: [SegmentSplit]? = nil,
    createdFromSplit: SegmentSplit? = nil
  ) {
    self.id = id
    self.confidence = confidence
    self.created_at = created_at
    self.embedding_id = embedding_id
    self.end_time = end_time
    self.is_invalidated = is_invalidated
    self.speaker_label = speaker_label
    self.start_time = start_time
    self.speakerAssignments = speakerAssignments
    self.diarizationRun = diarizationRun
    self.splits = splits
    self.createdFromSplit = createdFromSplit
  }
}


public struct Publication: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "publications" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var external_id: String
  public var ingested_at: String
  public var name: String
  public var publication_type: String
  public var raw_metadata: AnyCodable?
  public var url: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to speakers via 'speakersPublications'
  /// - Note: Only populated when queried with `.with(\.regularSpeakers)`
  public var regularSpeakers: [Speaker]?

  /// Link to videos via 'videosPublication'
  /// - Note: Only populated when queried with `.with(\.videos)`
  public var videos: [Video]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    external_id: String,
    ingested_at: String,
    name: String,
    publication_type: String,
    raw_metadata: AnyCodable? = nil,
    url: String,
    regularSpeakers: [Speaker]? = nil,
    videos: [Video]? = nil
  ) {
    self.id = id
    self.external_id = external_id
    self.ingested_at = ingested_at
    self.name = name
    self.publication_type = publication_type
    self.raw_metadata = raw_metadata
    self.url = url
    self.regularSpeakers = regularSpeakers
    self.videos = videos
  }
}


public struct SegmentSplit: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "segmentSplits" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var split_at: String
  public var split_by: String
  public var split_time: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to diarizationSegments via 'segmentSplitsOriginalSegment'
  /// - Note: Only populated when queried with `.with(\.originalSegment)`
  public var originalSegment: DiarizationSegment?

  /// Link to diarizationSegments via 'segmentSplitsResultingSegments'
  /// - Note: Only populated when queried with `.with(\.resultingSegments)`
  public var resultingSegments: [DiarizationSegment]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    split_at: String,
    split_by: String,
    split_time: Double,
    originalSegment: DiarizationSegment? = nil,
    resultingSegments: [DiarizationSegment]? = nil
  ) {
    self.id = id
    self.split_at = split_at
    self.split_by = split_by
    self.split_time = split_time
    self.originalSegment = originalSegment
    self.resultingSegments = resultingSegments
  }
}


/// Link shazam catalog entries to media (new entity).
public struct ShazamCatalogEntry: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "shazamCatalogEntries" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var catalog_version: String?
  public var cataloged_at: String?
  public var end_time: Double?
  public var media_item_id: String?
  public var start_time: Double?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to media via 'shazamCatalogEntriesMedia'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: Media?

  /// Link to videos via 'shazamCatalogEntriesVideo'
  /// - Note: Only populated when queried with `.with(\.video)`
  public var video: Video?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    catalog_version: String? = nil,
    cataloged_at: String? = nil,
    end_time: Double? = nil,
    media_item_id: String? = nil,
    start_time: Double? = nil,
    media: Media? = nil,
    video: Video? = nil
  ) {
    self.id = id
    self.catalog_version = catalog_version
    self.cataloged_at = cataloged_at
    self.end_time = end_time
    self.media_item_id = media_item_id
    self.start_time = start_time
    self.media = media
    self.video = video
  }
}


public struct ShazamMatch: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "shazamMatches" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var artist: String
  public var created_at: String
  public var end_time: Double
  public var match_offset: Double?
  public var shazam_track_id: String
  public var start_time: Double
  public var title: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to videos via 'videosShazamMatches'
  /// - Note: Only populated when queried with `.with(\.video)`
  public var video: Video?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    artist: String,
    created_at: String,
    end_time: Double,
    match_offset: Double? = nil,
    shazam_track_id: String,
    start_time: Double,
    title: String,
    video: Video? = nil
  ) {
    self.id = id
    self.artist = artist
    self.created_at = created_at
    self.end_time = end_time
    self.match_offset = match_offset
    self.shazam_track_id = shazam_track_id
    self.start_time = start_time
    self.title = title
    self.video = video
  }
}


public struct SpeakerAssignment: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "speakerAssignments" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var assigned_at: String
  public var assigned_by: String
  public var confidence: Double?
  public var note: String?
  public var source: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to speakers via 'speakerAssignmentsSpeaker'
  /// - Note: Only populated when queried with `.with(\.speaker)`
  public var speaker: Speaker?

  /// Link to diarizationSegments via 'diarizationSegmentsSpeakerAssignments'
  /// - Note: Only populated when queried with `.with(\.diarizationSegment)`
  public var diarizationSegment: DiarizationSegment?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    assigned_at: String,
    assigned_by: String,
    confidence: Double? = nil,
    note: String? = nil,
    source: String,
    speaker: Speaker? = nil,
    diarizationSegment: DiarizationSegment? = nil
  ) {
    self.id = id
    self.assigned_at = assigned_at
    self.assigned_by = assigned_by
    self.confidence = confidence
    self.note = note
    self.source = source
    self.speaker = speaker
    self.diarizationSegment = diarizationSegment
  }
}


/// A person who speaks in media.
/// Speakers link a Person to their speaking roles. A person can have multiple
/// speaker entries (different roles, different media, different segments).
/// Note: Voice embeddings are stored in PostgreSQL (pgvector) and linked
/// via the speakerAssignments entity, not directly on
public struct Speaker: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "speakers" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var role: String
  public var is_human: Bool
  public var ingested_at: String
  public var metadata: AnyCodable?
  public var name: String
  public var embedding_centroid_id: String?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to people via 'speakersPerson'
  /// - Note: Only populated when queried with `.with(\.person)`
  public var person: Person?

  /// Link to publications via 'speakersPublications'
  /// - Note: Only populated when queried with `.with(\.publications)`
  public var publications: [Publication]?

  /// Link to media via 'mediaAuthor'
  /// - Note: Only populated when queried with `.with(\.authoredMedia)`
  public var authoredMedia: [Media]?

  /// Link to media via 'mediaNarrator'
  /// - Note: Only populated when queried with `.with(\.narratedMedia)`
  public var narratedMedia: [Media]?

  /// Link to speakerAssignments via 'speakerAssignmentsSpeaker'
  /// - Note: Only populated when queried with `.with(\.speakerAssignments)`
  public var speakerAssignments: [SpeakerAssignment]?

  /// Link to audiobooks via 'audiobooksNarrator'
  /// - Note: Only populated when queried with `.with(\.narratedAudiobooks)`
  public var narratedAudiobooks: [Audiobook]?

  /// Link to audiobooks via 'audiobooksAuthor'
  /// - Note: Only populated when queried with `.with(\.authoredAudiobooks)`
  public var authoredAudiobooks: [Audiobook]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    role: String,
    is_human: Bool,
    ingested_at: String,
    metadata: AnyCodable? = nil,
    name: String,
    embedding_centroid_id: String? = nil,
    person: Person? = nil,
    publications: [Publication]? = nil,
    authoredMedia: [Media]? = nil,
    narratedMedia: [Media]? = nil,
    speakerAssignments: [SpeakerAssignment]? = nil,
    narratedAudiobooks: [Audiobook]? = nil,
    authoredAudiobooks: [Audiobook]? = nil
  ) {
    self.id = id
    self.role = role
    self.is_human = is_human
    self.ingested_at = ingested_at
    self.metadata = metadata
    self.name = name
    self.embedding_centroid_id = embedding_centroid_id
    self.person = person
    self.publications = publications
    self.authoredMedia = authoredMedia
    self.narratedMedia = narratedMedia
    self.speakerAssignments = speakerAssignments
    self.narratedAudiobooks = narratedAudiobooks
    self.authoredAudiobooks = authoredAudiobooks
  }
}


public struct TranscriptionConfig: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "transcriptionConfigs" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var additional_params: AnyCodable?
  public var beam_size: Double?
  public var created_at: String
  public var language: String?
  public var model: String
  public var temperature: Double?
  public var tool: String
  public var vad_filter: Bool?
  public var word_timestamps: Bool

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to transcriptionRuns via 'transcriptionRunsConfig'
  /// - Note: Only populated when queried with `.with(\.transcriptionRuns)`
  public var transcriptionRuns: [TranscriptionRun]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    additional_params: AnyCodable? = nil,
    beam_size: Double? = nil,
    created_at: String,
    language: String? = nil,
    model: String,
    temperature: Double? = nil,
    tool: String,
    vad_filter: Bool? = nil,
    word_timestamps: Bool,
    transcriptionRuns: [TranscriptionRun]? = nil
  ) {
    self.id = id
    self.additional_params = additional_params
    self.beam_size = beam_size
    self.created_at = created_at
    self.language = language
    self.model = model
    self.temperature = temperature
    self.tool = tool
    self.vad_filter = vad_filter
    self.word_timestamps = word_timestamps
    self.transcriptionRuns = transcriptionRuns
  }
}


public struct TranscriptionRun: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "transcriptionRuns" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var cost_usd: Double?
  public var executed_at: String
  public var git_commit_sha: String?
  public var input_duration_seconds: Double?
  public var is_preferred: Bool
  public var logs: AnyCodable?
  public var peak_memory_mb: Double?
  public var pipeline_script: String?
  public var processing_time_seconds: Double?
  public var tool_version: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to transcriptionConfigs via 'transcriptionRunsConfig'
  /// - Note: Only populated when queried with `.with(\.config)`
  public var config: TranscriptionConfig?

  /// Link to words via 'transcriptionRunsWords'
  /// - Note: Only populated when queried with `.with(\.words)`
  public var words: [Word]?

  /// Link to media via 'mediaTranscriptionRuns'
  /// - Note: Only populated when queried with `.with(\.media)`
  public var media: Media?

  /// Link to videos via 'videosTranscriptionRuns'
  /// - Note: Only populated when queried with `.with(\.video)`
  public var video: Video?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    cost_usd: Double? = nil,
    executed_at: String,
    git_commit_sha: String? = nil,
    input_duration_seconds: Double? = nil,
    is_preferred: Bool,
    logs: AnyCodable? = nil,
    peak_memory_mb: Double? = nil,
    pipeline_script: String? = nil,
    processing_time_seconds: Double? = nil,
    tool_version: String,
    config: TranscriptionConfig? = nil,
    words: [Word]? = nil,
    media: Media? = nil,
    video: Video? = nil
  ) {
    self.id = id
    self.cost_usd = cost_usd
    self.executed_at = executed_at
    self.git_commit_sha = git_commit_sha
    self.input_duration_seconds = input_duration_seconds
    self.is_preferred = is_preferred
    self.logs = logs
    self.peak_memory_mb = peak_memory_mb
    self.pipeline_script = pipeline_script
    self.processing_time_seconds = processing_time_seconds
    self.tool_version = tool_version
    self.config = config
    self.words = words
    self.media = media
    self.video = video
  }
}


/// Link video (audio file) to its audiobook.
/// A video can be a chapter clip from an audiobook.
public struct Video: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "videos" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var description: String?
  public var duration: Double
  public var external_published_at: String?
  public var filepath: String?
  public var ingested_at: String
  public var raw_metadata: AnyCodable?
  public var source_id: String?
  public var title: String
  public var url: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to diarizationRuns via 'videosDiarizationRuns'
  /// - Note: Only populated when queried with `.with(\.diarizationRuns)`
  public var diarizationRuns: [DiarizationRun]?

  /// Link to publications via 'videosPublication'
  /// - Note: Only populated when queried with `.with(\.publication)`
  public var publication: Publication?

  /// Link to shazamMatches via 'videosShazamMatches'
  /// - Note: Only populated when queried with `.with(\.shazamMatches)`
  public var shazamMatches: [ShazamMatch]?

  /// Link to transcriptionRuns via 'videosTranscriptionRuns'
  /// - Note: Only populated when queried with `.with(\.transcriptionRuns)`
  public var transcriptionRuns: [TranscriptionRun]?

  /// Link to audiobooks via 'videosAudiobook'
  /// - Note: Only populated when queried with `.with(\.audiobook)`
  public var audiobook: Audiobook?

  /// Link to audiobookChapters via 'videosAudiobookChapter'
  /// - Note: Only populated when queried with `.with(\.audiobookChapter)`
  public var audiobookChapter: AudiobookChapter?

  /// Link to shazamCatalogEntries via 'shazamCatalogEntriesVideo'
  /// - Note: Only populated when queried with `.with(\.shazamCatalogEntries)`
  public var shazamCatalogEntries: [ShazamCatalogEntry]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    description: String? = nil,
    duration: Double,
    external_published_at: String? = nil,
    filepath: String? = nil,
    ingested_at: String,
    raw_metadata: AnyCodable? = nil,
    source_id: String? = nil,
    title: String,
    url: String,
    diarizationRuns: [DiarizationRun]? = nil,
    publication: Publication? = nil,
    shazamMatches: [ShazamMatch]? = nil,
    transcriptionRuns: [TranscriptionRun]? = nil,
    audiobook: Audiobook? = nil,
    audiobookChapter: AudiobookChapter? = nil,
    shazamCatalogEntries: [ShazamCatalogEntry]? = nil
  ) {
    self.id = id
    self.description = description
    self.duration = duration
    self.external_published_at = external_published_at
    self.filepath = filepath
    self.ingested_at = ingested_at
    self.raw_metadata = raw_metadata
    self.source_id = source_id
    self.title = title
    self.url = url
    self.diarizationRuns = diarizationRuns
    self.publication = publication
    self.shazamMatches = shazamMatches
    self.transcriptionRuns = transcriptionRuns
    self.audiobook = audiobook
    self.audiobookChapter = audiobookChapter
    self.shazamCatalogEntries = shazamCatalogEntries
  }
}


public struct Word: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "words" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var confidence: Double?
  public var end_time: Double
  public var ingested_at: String
  public var start_time: Double
  public var text: String
  public var transcription_segment_index: Double?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to wordTextCorrections via 'wordsTextCorrections'
  /// - Note: Only populated when queried with `.with(\.textCorrections)`
  public var textCorrections: [WordTextCorrection]?

  /// Link to transcriptionRuns via 'transcriptionRunsWords'
  /// - Note: Only populated when queried with `.with(\.transcriptionRun)`
  public var transcriptionRun: TranscriptionRun?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    confidence: Double? = nil,
    end_time: Double,
    ingested_at: String,
    start_time: Double,
    text: String,
    transcription_segment_index: Double? = nil,
    textCorrections: [WordTextCorrection]? = nil,
    transcriptionRun: TranscriptionRun? = nil
  ) {
    self.id = id
    self.confidence = confidence
    self.end_time = end_time
    self.ingested_at = ingested_at
    self.start_time = start_time
    self.text = text
    self.transcription_segment_index = transcription_segment_index
    self.textCorrections = textCorrections
    self.transcriptionRun = transcriptionRun
  }
}


public struct WordTextCorrection: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "wordTextCorrections" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var corrected_at: String
  public var corrected_by: String
  public var corrected_text: String
  public var note: String?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to words via 'wordsTextCorrections'
  /// - Note: Only populated when queried with `.with(\.word)`
  public var word: Word?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    corrected_at: String,
    corrected_by: String,
    corrected_text: String,
    note: String? = nil,
    word: Word? = nil
  ) {
    self.id = id
    self.corrected_at = corrected_at
    self.corrected_by = corrected_by
    self.corrected_text = corrected_text
    self.note = note
    self.word = word
  }
}


/// Audiobook entity for tracking audiobook metadata.
/// Links to speakers (narrator, author) and chapters.
/// Note: narrator and author are stored as links to speakers, not as string fields.
public struct Audiobook: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "audiobooks" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var asin: String
  public var sku: String
  public var runtime_seconds: Double
  public var chapter_count: Double
  public var ingested_at: String
  public var raw_metadata: AnyCodable?

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to speakers via 'audiobooksNarrator'
  /// - Note: Only populated when queried with `.with(\.narrator)`
  public var narrator: Speaker?

  /// Link to speakers via 'audiobooksAuthor'
  /// - Note: Only populated when queried with `.with(\.author)`
  public var author: Speaker?

  /// Link to audiobookChapters via 'audiobookChaptersAudiobook'
  /// - Note: Only populated when queried with `.with(\.chapters)`
  public var chapters: [AudiobookChapter]?

  /// Link to videos via 'videosAudiobook'
  /// - Note: Only populated when queried with `.with(\.audioFiles)`
  public var audioFiles: [Video]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    title: String,
    asin: String,
    sku: String,
    runtime_seconds: Double,
    chapter_count: Double,
    ingested_at: String,
    raw_metadata: AnyCodable? = nil,
    narrator: Speaker? = nil,
    author: Speaker? = nil,
    chapters: [AudiobookChapter]? = nil,
    audioFiles: [Video]? = nil
  ) {
    self.id = id
    self.title = title
    self.asin = asin
    self.sku = sku
    self.runtime_seconds = runtime_seconds
    self.chapter_count = chapter_count
    self.ingested_at = ingested_at
    self.raw_metadata = raw_metadata
    self.narrator = narrator
    self.author = author
    self.chapters = chapters
    self.audioFiles = audioFiles
  }
}


/// Audiobook chapter entity for tracking chapter/sub-chapter metadata.
/// Chapters have timestamps (start_time_ms, end_time_ms) rather than page numbers.
/// Sub-chapters link to their parent chapter via the parent link.
public struct AudiobookChapter: EntityIdentifiable, Codable, Sendable {
  public static var namespace: String { "audiobookChapters" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var chapter_number: Double
  public var start_time_ms: Double
  public var end_time_ms: Double
  public var length_ms: Double
  public var is_subchapter: Bool
  public var parent_chapter_number: Double?
  public var ingested_at: String

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to audiobooks via 'audiobookChaptersAudiobook'
  /// - Note: Only populated when queried with `.with(\.audiobook)`
  public var audiobook: Audiobook?

  /// Link to audiobookChapters via 'audiobookChaptersParent'
  /// - Note: Only populated when queried with `.with(\.parentChapter)`
  public var parentChapter: AudiobookChapter?

  /// Link to audiobookChapters via 'audiobookChaptersParent'
  /// - Note: Only populated when queried with `.with(\.subchapters)`
  public var subchapters: [AudiobookChapter]?

  /// Link to videos via 'videosAudiobookChapter'
  /// - Note: Only populated when queried with `.with(\.audioFiles)`
  public var audioFiles: [Video]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString,
    title: String,
    chapter_number: Double,
    start_time_ms: Double,
    end_time_ms: Double,
    length_ms: Double,
    is_subchapter: Bool,
    parent_chapter_number: Double? = nil,
    ingested_at: String,
    audiobook: Audiobook? = nil,
    parentChapter: AudiobookChapter? = nil,
    subchapters: [AudiobookChapter]? = nil,
    audioFiles: [Video]? = nil
  ) {
    self.id = id
    self.title = title
    self.chapter_number = chapter_number
    self.start_time_ms = start_time_ms
    self.end_time_ms = end_time_ms
    self.length_ms = length_ms
    self.is_subchapter = is_subchapter
    self.parent_chapter_number = parent_chapter_number
    self.ingested_at = ingested_at
    self.audiobook = audiobook
    self.parentChapter = parentChapter
    self.subchapters = subchapters
    self.audioFiles = audioFiles
  }
}


