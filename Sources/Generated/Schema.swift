// Schema.swift
// Generated by InstantSchemaCodegen
// 2025-12-18T07:35:59Z
//
// DO NOT EDIT - This file is generated from your InstantDB schema.
// Any changes will be overwritten on the next codegen run.

import Foundation
import InstantDB
import IdentifiedCollections
import SharingInstant

// MARK: - Schema Namespace

/// Type-safe schema namespace with auto-derived SharedKeys.
///
/// Use these static properties to create type-safe queries:
///
/// ```swift
/// // Basic sync
/// @Shared(Schema.$files)
/// private var items: IdentifiedArrayOf<$file> = []
///
/// // With ordering
/// @Shared(Schema.$files.orderBy(\.path, .desc))
/// private var items: IdentifiedArrayOf<$file> = []
/// ```
public enum Schema {
  /// $file entity - bidirectional sync
  public static let $files = EntityKey<$file>(namespace: "$files")

  /// $user entity - bidirectional sync
  public static let $users = EntityKey<$user>(namespace: "$users")

  /// Person entity - bidirectional sync
  ///
  /// A person in the real world.
  /// People exist independently of their roles. A person may be an author,
  /// narrator, podcast host, guest making an appearance, article writer,
  /// or just referenced/mentioned in media. Not all
  public static let people = EntityKey<Person>(namespace: "people")

  /// Media entity - bidirectional sync
  ///
  /// A piece of
  public static let media = EntityKey<Media>(namespace: "media")

  /// MediaFile entity - bidirectional sync
  ///
  /// A file storing media content, either locally or remotely.
  /// Supports distributed caching: the same media may have files on multiple
  /// machines. Query by machine_id to find files available locally.
  /// Machine identification: Use IOPlatformUUID on macOS (stable, unique per machine).
  /// Get it via: ioreg -rd1 -c IOPlatformExpertDevice | grep IOPlatformUUID
  /// Example: "CF17FBE0-0E64-5426-8FC8-00DB233891F4"
  /// Examples:
  /// - Local MP3: machine_id="CF17FBE0-...", path="/Users/me/audiobooks/new-earth.mp3"
  /// - Server copy: machine_id="ABC123...", path="/srv/audiobooks/new-earth.mp3"
  /// - Remote URL: machine_id=null, remote_url="https:cdn.example.com/new-earth.mp3"
  /// Links:
  /// - media: The Media entity this file belongs to
  public static let mediaFiles = EntityKey<MediaFile>(namespace: "mediaFiles")

  /// Segment entity - bidirectional sync
  ///
  /// A named time range within media.
  /// Platform-agnostic: represents chapters, sections, tracks, or any named
  /// portion of media. Can be nested (parent/child) for sub-chapters.
  /// Source types (how the segment was created):
  /// - "import": Imported from external metadata
  /// - "manual": Manually annotated by a user
  /// - "auto": Auto-detected (silence detection, topic change, etc.)
  /// - "script": Created by an ingestion script
  /// Source (where the data came from, when source_type is "import" or "script"):
  /// - "audible_json": Audible chapter JSON file
  /// - "youtube_api": YouTube Data API chapters
  /// - "audio_ingestion.py": Our audio ingestion script
  /// - etc.
  /// Examples:
  /// - Audiobook chapter: "Chapter One: The Ego" (parent)
  /// - Audiobook sub-chapter: "Evocation" (child of above)
  /// - Podcast segment: "Interview", "Ad Break"
  /// Links:
  /// - media: The Media this segment belongs to
  /// - parent: Parent segment (for sub-chapters/nested sections)
  /// - children: Child
  public static let segments = EntityKey<Segment>(namespace: "segments")

  /// Platform entity - bidirectional sync
  ///
  /// An external platform where media or people can be found.
  /// Examples:
  /// - YouTube (video, text posts)
  /// - Audible (audiobooks)
  /// - Spotify (podcasts, music)
  /// - Twitter/X (profiles, posts, videos)
  /// - Medium (articles)
  /// - dev.to (articles)
  /// - Wikipedia (reference)
  /// - Wikidata (structured data)
  /// - Libby (library audiobooks/ebooks)
  /// Links:
  /// - externalMediaIds: Media linked to this platform
  /// - externalPeopleIds: People linked to this platform
  /// - externalSegmentIds: Segments linked to this platform
  public static let platforms = EntityKey<Platform>(namespace: "platforms")

  /// ExternalMediaId entity - bidirectional sync
  ///
  /// Links media to an external platform with platform-specific identifiers.
  /// Examples:
  /// - Audible: platform="Audible", external_id="B002V0RAUU",
  /// normalized_url="https:www.audible.com/pd/B002V0RAUU"
  /// - YouTube: platform="YouTube", external_id="jNQXAC9IVRw",
  /// normalized_url="https:www.youtube.com/watch?v=jNQXAC9IVRw"
  /// (Note: YouTube has many URL formats - use yt-dlp's URL normalization)
  /// Links:
  /// - media: The Media entity this refers to
  /// - platform: The Platform this ID is on
  /// - accessMetadata: Access restrictions (paywall, subscription, etc.)
  public static let externalMediaIds = EntityKey<ExternalMediaId>(namespace: "externalMediaIds")

  /// ExternalPeopleId entity - bidirectional sync
  ///
  /// Links people to their profiles on external platforms.
  /// Examples:
  /// - YouTube channel: platform="YouTube", external_id="UCxxxxxx",
  /// normalized_url="https:www.youtube.com/@lexfridman"
  /// - Twitter: platform="Twitter", external_id="lexfridman",
  /// normalized_url="https:twitter.com/lexfridman"
  /// - Wikidata: platform="Wikidata", external_id="Q123456",
  /// normalized_url="https:www.wikidata.org/wiki/Q123456"
  /// - Wikipedia: platform="Wikipedia", external_id="Eckhart_Tolle",
  /// normalized_url="https:en.wikipedia.org/wiki/Eckhart_Tolle"
  /// Links:
  /// - person: The People entity this refers to
  /// - platform: The Platform this profile is on
  public static let externalPeopleIds = EntityKey<ExternalPeopleId>(namespace: "externalPeopleIds")

  /// ExternalSegmentId entity - bidirectional sync
  ///
  /// Links segments to platform-specific deep links.
  /// Examples:
  /// - YouTube timestamp: normalized_url="https:www.youtube.com/watch?v=jNQXAC9IVRw&t=120"
  /// - Spotify chapter: normalized_url="spotify:episode:xxx#t=120"
  /// Links:
  /// - segment: The Segment entity this refers to
  /// - platform: The Platform this link is on
  public static let externalSegmentIds = EntityKey<ExternalSegmentId>(namespace: "externalSegmentIds")

  /// AccessMetadata entity - bidirectional sync
  ///
  /// Describes access restrictions for external media.
  /// Linked to ExternalMediaIds because access varies by platform:
  /// - Same audiobook might be subscription on Audible, one-time on Apple Books,
  /// or free via Libby (library)
  /// - Same video might be free on YouTube, paywalled on Nebula
  /// Access types (what gets in your way before you can access content):
  /// - "free": No payment required, no account needed
  /// - "free_with_ads": Free but has advertisements
  /// - "account_required": Must create account (no additional payment)
  /// - "subscription": Requires ongoing subscription (e.g., Audible, Netflix)
  /// - "one_time_purchase": Single payment to own
  /// - "rental": Temporary access for a fee
  /// Links:
  /// - externalMediaId: The external media link this describes
  public static let accessMetadata = EntityKey<AccessMetadata>(namespace: "accessMetadata")

  /// DiarizationConfig entity - bidirectional sync
  public static let diarizationConfigs = EntityKey<DiarizationConfig>(namespace: "diarizationConfigs")

  /// DiarizationRun entity - bidirectional sync
  public static let diarizationRuns = EntityKey<DiarizationRun>(namespace: "diarizationRuns")

  /// DiarizationSegment entity - bidirectional sync
  public static let diarizationSegments = EntityKey<DiarizationSegment>(namespace: "diarizationSegments")

  /// Publication entity - bidirectional sync
  public static let publications = EntityKey<Publication>(namespace: "publications")

  /// SegmentSplit entity - bidirectional sync
  public static let segmentSplits = EntityKey<SegmentSplit>(namespace: "segmentSplits")

  /// ShazamCatalogEntry entity - bidirectional sync
  ///
  /// Link shazam catalog entries to media (new entity).
  public static let shazamCatalogEntries = EntityKey<ShazamCatalogEntry>(namespace: "shazamCatalogEntries")

  /// ShazamMatch entity - bidirectional sync
  public static let shazamMatches = EntityKey<ShazamMatch>(namespace: "shazamMatches")

  /// SpeakerAssignment entity - bidirectional sync
  public static let speakerAssignments = EntityKey<SpeakerAssignment>(namespace: "speakerAssignments")

  /// Speaker entity - bidirectional sync
  ///
  /// A person who speaks in media.
  /// Speakers link a Person to their speaking roles. A person can have multiple
  /// speaker entries (different roles, different media, different segments).
  /// Note: Voice embeddings are stored in PostgreSQL (pgvector) and linked
  /// via the speakerAssignments entity, not directly on
  public static let speakers = EntityKey<Speaker>(namespace: "speakers")

  /// TranscriptionConfig entity - bidirectional sync
  public static let transcriptionConfigs = EntityKey<TranscriptionConfig>(namespace: "transcriptionConfigs")

  /// TranscriptionRun entity - bidirectional sync
  public static let transcriptionRuns = EntityKey<TranscriptionRun>(namespace: "transcriptionRuns")

  /// Video entity - bidirectional sync
  ///
  /// Link video (audio file) to its audiobook.
  /// A video can be a chapter clip from an audiobook.
  public static let videos = EntityKey<Video>(namespace: "videos")

  /// Word entity - bidirectional sync
  public static let words = EntityKey<Word>(namespace: "words")

  /// WordTextCorrection entity - bidirectional sync
  public static let wordTextCorrections = EntityKey<WordTextCorrection>(namespace: "wordTextCorrections")

  /// Audiobook entity - bidirectional sync
  ///
  /// Audiobook entity for tracking audiobook metadata.
  /// Links to speakers (narrator, author) and chapters.
  /// Note: narrator and author are stored as links to speakers, not as string fields.
  public static let audiobooks = EntityKey<Audiobook>(namespace: "audiobooks")

  /// AudiobookChapter entity - bidirectional sync
  ///
  /// Audiobook chapter entity for tracking chapter/sub-chapter metadata.
  /// Chapters have timestamps (start_time_ms, end_time_ms) rather than page numbers.
  /// Sub-chapters link to their parent chapter via the parent link.
  public static let audiobookChapters = EntityKey<AudiobookChapter>(namespace: "audiobookChapters")

}
