/// ═══════════════════════════════════════════════════════════════════════════════
/// Entities.swift
/// Generated by InstantSchemaCodegen
/// ═══════════════════════════════════════════════════════════════════════════════
///
/// ⚠️  DO NOT EDIT - This file is generated from your InstantDB schema.
/// Any changes will be overwritten on the next codegen run.
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// WHAT THIS FILE IS
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// This file contains Swift structs for each entity in your InstantDB schema.
/// These structs conform to `EntityIdentifiable`, `Codable`, and `Sendable`,
/// making them ready for use with `@Shared` and `@SharedReader`.
/// Each entity has:
/// • An `id` field (auto-generated UUID by default)
/// • All fields from your schema with proper Swift types
/// • Optional link properties (populated when using `.with()` queries)
/// • A memberwise initializer with sensible defaults
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// HOW TO USE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Create entities using the generated initializers, then add them to
/// synced collections using `$collection.withLock { }`.
/// • Create: `let item = Fact(...)`
/// • Add: `$items.withLock { $0.append(item) }`
/// • Update: `$items.withLock { $0[index].field = newValue }`
/// • Delete: `$items.withLock { $0.remove(id: item.id) }`
///
/// ─────────────────────────────────────────────────────────────────────────────────
/// QUICK START - Copy & Paste Example
/// ─────────────────────────────────────────────────────────────────────────────────

/* Copy-pasteable example:

import SwiftUI
import SharingInstant
import IdentifiedCollections

struct FactListContentView: View {
  @Shared(Schema.facts)
  private var items: IdentifiedArrayOf<Fact> = []

  var body: some View {
    List {
      ForEach(items) { item in
        Text("\(item.id)")
      }
    }
  }

  private func addItem() {
    let item = Fact(
      count: Date().timeIntervalSince1970,
      text: "Text value"
    )
    $items.withLock { $0.append(item) }
  }

  private func deleteItem(_ item: Fact) {
    $items.withLock { $0.remove(id: item.id) }
  }
}
*/

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// AVAILABLE IN THIS FILE
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// InstantFile {
///   id: String
///   path: String
///   url: String
/// }
///
/// InstantUser {
///   id: String
///   email: String?
///   imageURL: String?
///   type: String?
/// }
///
/// Fact {
///   id: String
///   count: Double
///   text: String
/// }
///
/// Log {
///   id: String
///   level: String
///   message: String
///   jsonPayload: String?
///   file: String
///   line: Double
///   timestamp: Double
///   formattedDate: String
///   timezone: String
/// }
///
/// Todo {
///   id: String
///   createdAt: Double
///   done: Bool
///   title: String
/// }
///
/// Profile {
///   id: String
///   displayName: String
///   handle: String
///   bio: String?
///   avatarUrl: String?
///   createdAt: Double
///   posts: [Post]?  // Link (has: many)
///   comments: [Comment]?  // Link (has: many)
///   likes: [Like]?  // Link (has: many)
/// }
///
/// Post {
///   id: String
///   content: String
///   imageUrl: String?
///   createdAt: Double
///   likesCount: Double
///   comments: [Comment]?  // Link (has: many)
///   likes: [Like]?  // Link (has: many)
///   author: Profile?  // Link (has: one)
/// }
///
/// Comment {
///   id: String
///   text: String
///   createdAt: Double
///   author: Profile?  // Link (has: one)
///   post: Post?  // Link (has: one)
/// }
///
/// Like {
///   id: String
///   createdAt: Double
///   profile: Profile?  // Link (has: one)
///   post: Post?  // Link (has: one)
/// }
///
/// Tile {
///   id: String
///   x: Double
///   y: Double
///   color: String
///   createdAt: Double
///   board: Board?  // Link (has: one)
/// }
///
/// Board {
///   id: String
///   title: String
///   createdAt: Double
///   tiles: [Tile]?  // Link (has: many)
/// }
///

///
/// ─────────────────────────────────────────────────────────────────────────────────
/// GENERATION INFO
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// Mode:            Production (full traceability)
/// Generated:       December 30, 2025 at 8:23 PM EST
/// Machine:         mlustig-hy7l9xrd61.local (Apple M4 Pro, macOS 26.2)
/// Generator:       Sources/instant-schema/main.swift
/// Source Schema:   Examples/CaseStudies/instant.schema.ts

/* To regenerate this file, run:

swift run instant-schema generate \
  --from Examples/CaseStudies/instant.schema.ts \
  --to Examples/CaseStudies/Models/Generated
*/
/// ─────────────────────────────────────────────────────────────────────────────────
/// GIT STATE AT GENERATION
/// ─────────────────────────────────────────────────────────────────────────────────
///
/// HEAD Commit:
///   SHA:      9e86d9473bf7479d459636330853fa2e4a72a1f4
///   Date:     December 30, 2025 at 7:12 PM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  chore: Regenerate schema files with final commit hash
///
/// Schema File Last Modified:
///   SHA:      522ffbf617207b60ecfa647b2d1dc6b9bfa3a7ff
///   Date:     December 22, 2025 at 6:46 AM EST
///   Author:   Michael Lustig <mlustig@hioscar.com>
///   Message:  fix: Remove recursive self-link to fix Swift compilation
///
/// ═══════════════════════════════════════════════════════════════════════════════

import Foundation
import InstantDB
import SharingInstant

public struct InstantFile: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "$files" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var path: String
  public var url: String

  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    path: String,
    url: String
  ) {
    self.id = id
    self.path = path
    self.url = url
  }
}


public struct InstantUser: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "$users" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var email: String?
  public var imageURL: String?
  public var type: String?

  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    email: String? = nil,
    imageURL: String? = nil,
    type: String? = nil
  ) {
    self.id = id
    self.email = email
    self.imageURL = imageURL
    self.type = type
  }
}


public struct Fact: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "facts" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var count: Double
  public var text: String

  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    count: Double,
    text: String
  ) {
    self.id = id
    self.count = count
    self.text = text
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, count, text
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.count = try container.decode(FlexibleDouble.self, forKey: .count).wrappedValue
    self.text = try container.decode(String.self, forKey: .text)
  }
}


public struct Log: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "logs" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var level: String
  public var message: String
  public var jsonPayload: String?
  public var file: String
  public var line: Double
  public var timestamp: Double
  public var formattedDate: String
  public var timezone: String

  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    level: String,
    message: String,
    jsonPayload: String? = nil,
    file: String,
    line: Double,
    timestamp: Double,
    formattedDate: String,
    timezone: String
  ) {
    self.id = id
    self.level = level
    self.message = message
    self.jsonPayload = jsonPayload
    self.file = file
    self.line = line
    self.timestamp = timestamp
    self.formattedDate = formattedDate
    self.timezone = timezone
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, level, message, jsonPayload, file, line, timestamp, formattedDate, timezone
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.level = try container.decode(String.self, forKey: .level)
    self.message = try container.decode(String.self, forKey: .message)
    self.jsonPayload = try container.decodeIfPresent(String.self, forKey: .jsonPayload)
    self.file = try container.decode(String.self, forKey: .file)
    self.line = try container.decode(FlexibleDouble.self, forKey: .line).wrappedValue
    self.timestamp = try container.decode(FlexibleDouble.self, forKey: .timestamp).wrappedValue
    self.formattedDate = try container.decode(String.self, forKey: .formattedDate)
    self.timezone = try container.decode(String.self, forKey: .timezone)
  }
}


public struct Todo: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "todos" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var createdAt: Double
  public var done: Bool
  public var title: String

  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    createdAt: Double,
    done: Bool,
    title: String
  ) {
    self.id = id
    self.createdAt = createdAt
    self.done = done
    self.title = title
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, createdAt, done, title
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.done = try container.decode(FlexibleBool.self, forKey: .done).wrappedValue
    self.title = try container.decode(String.self, forKey: .title)
  }
}


public struct Profile: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "profiles" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var displayName: String
  public var handle: String
  public var bio: String?
  public var avatarUrl: String?
  public var createdAt: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to posts via 'profilePosts'
  /// - Note: Only populated when queried with `.with(\.posts)`
  public var posts: [Post]?

  /// Link to comments via 'profileComments'
  /// - Note: Only populated when queried with `.with(\.comments)`
  public var comments: [Comment]?

  /// Link to likes via 'profileLikes'
  /// - Note: Only populated when queried with `.with(\.likes)`
  public var likes: [Like]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    displayName: String,
    handle: String,
    bio: String? = nil,
    avatarUrl: String? = nil,
    createdAt: Double,
    posts: [Post]? = nil,
    comments: [Comment]? = nil,
    likes: [Like]? = nil
  ) {
    self.id = id
    self.displayName = displayName
    self.handle = handle
    self.bio = bio
    self.avatarUrl = avatarUrl
    self.createdAt = createdAt
    self.posts = posts
    self.comments = comments
    self.likes = likes
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, displayName, handle, bio, avatarUrl, createdAt, posts, comments, likes
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.displayName = try container.decode(String.self, forKey: .displayName)
    self.handle = try container.decode(String.self, forKey: .handle)
    self.bio = try container.decodeIfPresent(String.self, forKey: .bio)
    self.avatarUrl = try container.decodeIfPresent(String.self, forKey: .avatarUrl)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.posts = try container.decodeIfPresent([Post].self, forKey: .posts)
    self.comments = try container.decodeIfPresent([Comment].self, forKey: .comments)
    self.likes = try container.decodeIfPresent([Like].self, forKey: .likes)
  }
}


public struct Post: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "posts" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var content: String
  public var imageUrl: String?
  public var createdAt: Double
  public var likesCount: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to comments via 'postComments'
  /// - Note: Only populated when queried with `.with(\.comments)`
  public var comments: [Comment]?

  /// Link to likes via 'postLikes'
  /// - Note: Only populated when queried with `.with(\.likes)`
  public var likes: [Like]?

  /// Link to profiles via 'profilePosts'
  /// - Note: Only populated when queried with `.with(\.author)`
  public var author: Profile?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    content: String,
    imageUrl: String? = nil,
    createdAt: Double,
    likesCount: Double,
    comments: [Comment]? = nil,
    likes: [Like]? = nil,
    author: Profile? = nil
  ) {
    self.id = id
    self.content = content
    self.imageUrl = imageUrl
    self.createdAt = createdAt
    self.likesCount = likesCount
    self.comments = comments
    self.likes = likes
    self.author = author
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, content, imageUrl, createdAt, likesCount, comments, likes, author
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.content = try container.decode(String.self, forKey: .content)
    self.imageUrl = try container.decodeIfPresent(String.self, forKey: .imageUrl)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.likesCount = try container.decode(FlexibleDouble.self, forKey: .likesCount).wrappedValue
    self.comments = try container.decodeIfPresent([Comment].self, forKey: .comments)
    self.likes = try container.decodeIfPresent([Like].self, forKey: .likes)
    self.author = try container.decodeIfPresent(Profile.self, forKey: .author)
  }
}


public struct Comment: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "comments" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var text: String
  public var createdAt: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to profiles via 'profileComments'
  /// - Note: Only populated when queried with `.with(\.author)`
  public var author: Profile?

  /// Link to posts via 'postComments'
  /// - Note: Only populated when queried with `.with(\.post)`
  public var post: Post?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    text: String,
    createdAt: Double,
    author: Profile? = nil,
    post: Post? = nil
  ) {
    self.id = id
    self.text = text
    self.createdAt = createdAt
    self.author = author
    self.post = post
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, text, createdAt, author, post
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.text = try container.decode(String.self, forKey: .text)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.author = try container.decodeIfPresent(Profile.self, forKey: .author)
    self.post = try container.decodeIfPresent(Post.self, forKey: .post)
  }
}


public struct Like: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "likes" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var createdAt: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to profiles via 'profileLikes'
  /// - Note: Only populated when queried with `.with(\.profile)`
  public var profile: Profile?

  /// Link to posts via 'postLikes'
  /// - Note: Only populated when queried with `.with(\.post)`
  public var post: Post?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    createdAt: Double,
    profile: Profile? = nil,
    post: Post? = nil
  ) {
    self.id = id
    self.createdAt = createdAt
    self.profile = profile
    self.post = post
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, createdAt, profile, post
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.profile = try container.decodeIfPresent(Profile.self, forKey: .profile)
    self.post = try container.decodeIfPresent(Post.self, forKey: .post)
  }
}


public struct Tile: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "tiles" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var x: Double
  public var y: Double
  public var color: String
  public var createdAt: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to boards via 'boardTiles'
  /// - Note: Only populated when queried with `.with(\.board)`
  public var board: Board?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    x: Double,
    y: Double,
    color: String,
    createdAt: Double,
    board: Board? = nil
  ) {
    self.id = id
    self.x = x
    self.y = y
    self.color = color
    self.createdAt = createdAt
    self.board = board
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, x, y, color, createdAt, board
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.x = try container.decode(FlexibleDouble.self, forKey: .x).wrappedValue
    self.y = try container.decode(FlexibleDouble.self, forKey: .y).wrappedValue
    self.color = try container.decode(String.self, forKey: .color)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.board = try container.decodeIfPresent(Board.self, forKey: .board)
  }
}


public struct Board: EntityIdentifiable, Codable, Sendable, Equatable {
  public static var namespace: String { "boards" }
  
  // MARK: - Fields
  
  /// The unique identifier for this entity
  public var id: String
  public var title: String
  public var createdAt: Double

  // MARK: - Links
  // Populated when queried with .with(...)

  /// Link to tiles via 'boardTiles'
  /// - Note: Only populated when queried with `.with(\.tiles)`
  public var tiles: [Tile]?


  // MARK: - Initializer

  public init(
    id: String = UUID().uuidString.lowercased(),
    title: String,
    createdAt: Double,
    tiles: [Tile]? = nil
  ) {
    self.id = id
    self.title = title
    self.createdAt = createdAt
    self.tiles = tiles
  }

  // MARK: - Custom Codable (handles InstantDB type quirks)

  private enum CodingKeys: String, CodingKey {
    case id, title, createdAt, tiles
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.id = try container.decode(String.self, forKey: .id)
    self.title = try container.decode(String.self, forKey: .title)
    self.createdAt = try container.decode(FlexibleDouble.self, forKey: .createdAt).wrappedValue
    self.tiles = try container.decodeIfPresent([Tile].self, forKey: .tiles)
  }
}


